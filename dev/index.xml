<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Devs on 木秀于南</title>
    <link>http://yjn93.github.io/dev/</link>
    <description>Recent content in Devs on 木秀于南</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© 2016 Jianan Yue. All right reserved.</copyright>
    <lastBuildDate>Thu, 05 Jan 2017 14:34:10 -0500</lastBuildDate>
    <atom:link href="http://yjn93.github.io/dev/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LeetCodeLocked</title>
      <link>http://yjn93.github.io/dev/LeetCodeLocked/</link>
      <pubDate>Thu, 05 Jan 2017 14:34:10 -0500</pubDate>
      
      <guid>http://yjn93.github.io/dev/LeetCodeLocked/</guid>
      <description>

&lt;h1 id=&#34;range-addition:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Range Addition&lt;/h1&gt;

&lt;p&gt;Assume you have an array of length n initialized with all 0&amp;rsquo;s and are given k update operations.&lt;/p&gt;

&lt;p&gt;Each operation is represented as a triplet: [startIndex, endIndex, inc] which increments each element of subarray A[startIndex &amp;hellip; endIndex] /(startIndex and endIndex inclusive) with inc.&lt;/p&gt;

&lt;p&gt;Return the modified array after all k operations were executed.&lt;/p&gt;

&lt;h2 id=&#34;example:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Example&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Given:

    length = 5,
    updates = [
        [1,  3,  2],
        [2,  4,  3],
        [0,  2, -2]
    ]

Output:

    [-2, 0, 3, 5, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;explanation:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Explanation&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Initial state:
[ 0, 0, 0, 0, 0 ]

After applying operation [1, 3, 2]:
[ 0, 2, 2, 2, 0 ]

After applying operation [2, 4, 3]:
[ 0, 2, 5, 5, 3 ]

After applying operation [0, 2, -2]:
[-2, 0, 3, 5, 3 ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;Only update the start and end+1 index every time is sufficient.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int[] getModifiedArray(int length, int[][] updates) {
        int[] result = new int[length];
        for(int[] update: updates) {
            result[update[0]] += update[2];
            if(update[1] &amp;lt; length-1)
                result[update[1]+1] -= update[2];
        }
        
        for(int i = 1; i &amp;lt; length; i ++)
            result[i] += result[i-1];
        return result;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;shortest-word-distance:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Shortest Word Distance&lt;/h1&gt;

&lt;p&gt;Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;p&gt;Assume that words = [&amp;ldquo;practice&amp;rdquo;, &amp;ldquo;makes&amp;rdquo;, &amp;ldquo;perfect&amp;rdquo;, &amp;ldquo;coding&amp;rdquo;, &amp;ldquo;makes&amp;rdquo;].&lt;/p&gt;

&lt;p&gt;Given word1 = “coding”, word2 = “practice”, return 3.&lt;/p&gt;

&lt;p&gt;Given word1 = &amp;ldquo;makes&amp;rdquo;, word2 = &amp;ldquo;coding&amp;rdquo;, return 1.&lt;/p&gt;

&lt;h2 id=&#34;solution-1:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public int shortestDistance(String[] words, String word1, String word2) {
        int p1 = -1, p2 = -1;
        int min = words.length;
        for(int i = 0; i &amp;lt; words.length; i ++) {
            if(words[i].equals(word1))
                p1 = i;
            if(words[i].equals(word2))
                p2 = i;
            if(p1 != -1 &amp;amp;&amp;amp; p2 != -1)
                min = Math.min(Math.abs(p2 - p1), min);
        }
        return min;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;follow-up-1:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Follow up 1&lt;/h2&gt;

&lt;p&gt;Now you are given the list of words and your method will be called repeatedly many times with different parameters. How would you optimize it?&lt;/p&gt;

&lt;p&gt;Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list.&lt;/p&gt;

&lt;h3 id=&#34;solution-2:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;Use HashMap&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class WordDistance {
    HashMap&amp;lt;String, List&amp;lt;Integer&amp;gt;&amp;gt; map;
    
    public WordDistance(String[] words) {
        map = new HashMap();
        for(int i = 0; i &amp;lt; words.length; i ++) {
            if(!map.containsKey(words[i]))
                map.put(words[i], new ArrayList());
            map.get(words[i]).add(i);
        }
    }

    public int shortest(String word1, String word2) {
        int min = Integer.MAX_VALUE;
        for(int i: map.get(word1)) {
            for(int j: map.get(word2)) 
                min = Math.min(Math.abs(i - j), min);
        }
        return min;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;follow-up-2:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Follow up 2&lt;/h2&gt;

&lt;p&gt;Now word1 could be the same as word2 and they represent two individual words in the list.&lt;/p&gt;

&lt;h3 id=&#34;solution-3:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;If we remove the boolean same variable, it can solve the basic problem.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int shortestWordDistance(String[] words, String word1, String word2) {
        int index = -1;
        int min = words.length;
        boolean same = word1.equals(word2);
        for(int i = 0; i &amp;lt; words.length; i ++) {
            if(words[i].equals(word1) || words[i].equals(word2)) {
                if(index != -1 &amp;amp;&amp;amp; (same || !words[index].equals(words[i]))){
                    min = Math.min(i - index, min);
                }
                index = i;
            }
        }
        return min;
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;zigzag-iterator:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Zigzag iterator&lt;/h1&gt;

&lt;p&gt;Given two 1d vectors, implement an iterator to return their elements alternately.&lt;/p&gt;

&lt;p&gt;For example, given two 1d vectors:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;v1 = [1, 2]
v2 = [3, 4, 5, 6]
By calling next repeatedly until hasNext returns false, the order of elements returned by next should be:
[1, 3, 2, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Follow up: What if you are given k 1d vectors? How well can your code be extended to such cases?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1,2,3]
[4,5,6,7]
[8,9]
It should return [1,4,8,2,5,9,3,6,7].
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-4:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;Uses a linkedlist to store the iterators in different vectors. Every time we call next(), we pop an element from the list, and re-add it to the end to cycle through the lists.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
public class ZigzagIterator {
    LinkedList&amp;lt;Iterator&amp;gt; list;
    
    public ZigzagIterator(List&amp;lt;Integer&amp;gt; v1, List&amp;lt;Integer&amp;gt; v2) {
        list = new LinkedList();
        if(!v1.isEmpty())
            list.add(v1.iterator());
        if(!v2.isEmpty())
            list.add(v2.iterator());
    }

    public int next() {
        Iterator cur = list.remove();
        int result = (int)cur.next();
        if(cur.hasNext()) list.add(cur);
        return result;
    }

    public boolean hasNext() {
        return !list.isEmpty();
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Many things need to be notice in code:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;For the member list, we need to specify its type as LinkedList, or Queue. If we use List&lt;Iterator&gt; list, we cannot use remove() or poll() method because they are not specified by interface List, but by Queue or Deque.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;After we got the Iterator cur, we need to convert cur.next() to (int), otherwise it will raise Object cannot convert to int exception.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;flip-game:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Flip Game&lt;/h1&gt;

&lt;p&gt;You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two consecutive &amp;ldquo;++&amp;rdquo; into &amp;ldquo;&amp;ndash;&amp;rdquo;. The game ends when a person can no longer make a move and therefore the other person will be the winner.&lt;/p&gt;

&lt;p&gt;Write a function to determine if the starting player can guarantee a win.&lt;/p&gt;

&lt;p&gt;For example, given s = &amp;ldquo;++++&amp;rdquo;, return true. The starting player can guarantee a win by flipping the middle &amp;ldquo;++&amp;rdquo; to become &amp;ldquo;+&amp;ndash;+&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;solution-5:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    Map&amp;lt;String, Boolean&amp;gt; winMap = new HashMap();
    
    public boolean canWin(String s) {
        if(winMap.containsKey(s)) return winMap.get(s);
        for(int i = -1; (i = s.indexOf(&amp;quot;++&amp;quot;, i + 1)) &amp;gt;= 0; ) {
            String t = s.substring(0, i) + &amp;quot;--&amp;quot; + s.substring(i+2);
            if(!canWin(t)) {
                winMap.put(s, true);
                return true;
            }
        }
        winMap.put(s, false);
        return false;
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;generalized-abbreviation:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Generalized Abbreviation&lt;/h1&gt;

&lt;p&gt;Write a function to generate the generalized abbreviations of a word.&lt;/p&gt;

&lt;h2 id=&#34;example-1:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Example&lt;/h2&gt;

&lt;p&gt;Given word = &amp;ldquo;word&amp;rdquo;, return the following list (order does not matter):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;word&amp;quot;, &amp;quot;1ord&amp;quot;, &amp;quot;w1rd&amp;quot;, &amp;quot;wo1d&amp;quot;, &amp;quot;wor1&amp;quot;, &amp;quot;2rd&amp;quot;, &amp;quot;w2d&amp;quot;, &amp;quot;wo2&amp;quot;, &amp;quot;1o1d&amp;quot;, &amp;quot;1or1&amp;quot;, &amp;quot;w1r1&amp;quot;, &amp;quot;1o2&amp;quot;, &amp;quot;2r1&amp;quot;, &amp;quot;3d&amp;quot;, &amp;quot;w3&amp;quot;, &amp;quot;4&amp;quot;]

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-6:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;For each character, we can choose to put or not put it in the abbreviation. So we can use backtracking&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
    public List&amp;lt;String&amp;gt; generateAbbreviations(String word) {
        List&amp;lt;String&amp;gt; result = new ArrayList();
        dfs(result, new StringBuilder(), word, 0, 0);
        return result;
    }
    
    public void dfs(List&amp;lt;String&amp;gt; result, StringBuilder sb, String word, int pos, int count) {
        int len = sb.length();
        if(pos == word.length()) {
            if(count &amp;gt; 0) sb.append(count);
            result.add(sb.toString());
        } else {
            dfs(result, sb, word, pos+1, count+1);
            if(count &amp;gt; 0)
                sb.append(count);
            dfs(result, sb.append(word.charAt(pos)), word, pos+1, 0);
        }
        sb.setLength(len);
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;maximum-size-subarray-sum-equals-k:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Maximum Size Subarray Sum Equals k&lt;/h1&gt;

&lt;p&gt;Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn&amp;rsquo;t one, return 0 instead.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
Example 1:
Given nums = [1, -1, 5, -2, 3], k = 3,
return 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longest)

Example 2:
Given nums = [-2, -1, 2, 1], k = 1,
return 2. (because the subarray [-1, 2] sums to 1 and is the longest

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-7:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;I didn&amp;rsquo;t come up with the idea of using map.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int maxSubArrayLen(int[] nums, int k) {
        int max = 0, sum = 0;
        HashMap&amp;lt;Integer, Integer&amp;gt; map = new HashMap();
        for(int i = 0; i &amp;lt; nums.length; i ++) {
            sum += nums[i];
            if(sum == k) 
                max = i + 1;
            else if(map.containsKey(sum - k))
                max = Math.max(max, i - map.get(sum - k));
            if(!map.containsKey(sum))
                map.put(sum, i);
        }
        return max;
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;factor-combinations:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Factor Combinations&lt;/h1&gt;

&lt;p&gt;Numbers can be regarded as product of its factors. Write a function that takes an integer n and return all possible combinations of its factors,&lt;/p&gt;

&lt;h2 id=&#34;example-2:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Example&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;input: 1
output: []

input: 37
output: []

input: 12
output:
[
  [2, 6],
  [2, 2, 3],
  [3, 4]
]

input: 32
output:
[
  [2, 16],
  [2, 2, 8],
  [2, 2, 2, 4],
  [2, 2, 2, 2, 2],
  [2, 4, 4],
  [4, 8]
]

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-8:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;Backtracking, similar to combination sum.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; getFactors(int n) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList();
        helper(result, new ArrayList(), n, 2);
        return result;
    }
    
    public void helper(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result, List&amp;lt;Integer&amp;gt; cur, int n, int start) {
        for(int i = start; i &amp;lt;= n / i; i ++) {
            if(n % i == 0) {
                cur.add(i);
                cur.add(n/i);
                result.add(new ArrayList(cur));
                cur.remove(cur.size()-1);
                helper(result, cur, n/i, i);
                cur.remove(cur.size()-1);
            }
        }
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;bomb-enemy:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Bomb Enemy&lt;/h1&gt;

&lt;p&gt;Given a 2D grid, each cell is either a wall &amp;lsquo;W&amp;rsquo;, an enemy &amp;lsquo;E&amp;rsquo; or empty &amp;lsquo;0&amp;rsquo; (the number zero), return the maximum enemies you can kill using one bomb.&lt;/p&gt;

&lt;p&gt;The bomb kills all the enemies in the same row and column from the planted point until it hits the wall since the wall is too strong to be destroyed.&lt;/p&gt;

&lt;p&gt;Note that you can only put the bomb at an empty cell.&lt;/p&gt;

&lt;h2 id=&#34;example-3:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Example&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;For the given grid

0 E 0 0
E 0 W E
0 E 0 0

return 3. (Placing a bomb at (1,1) kills 3 enemies)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-9:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;Using dp, only need to record number of enemies in current row and every column. If encounter a wall, update the values.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int maxKilledEnemies(char[][] grid) {
        if(grid == null || grid.length == 0 || grid[0].length == 0)
            return 0;
        int m = grid.length, n = grid[0].length;
        int row = 0;
        int[] col = new int[n];
        int max = 0;
        for(int i = 0; i &amp;lt; m; i ++) {
            for(int j = 0; j &amp;lt; n; j ++) {
                if(grid[i][j] == &#39;W&#39;) continue;
                if(j == 0 || grid[i][j-1] == &#39;W&#39;) {
                    row = 0;
                    for(int k = j; k &amp;lt; n &amp;amp;&amp;amp; grid[i][k] != &#39;W&#39;; k ++)
                        row += grid[i][k] == &#39;E&#39; ? 1 : 0;
                }
                if(i == 0 || grid[i-1][j] == &#39;W&#39;) {
                    col[j] = 0;
                    for(int k = i; k &amp;lt; m &amp;amp;&amp;amp; grid[k][j] != &#39;W&#39;; k ++)
                        col[j] += grid[k][j] == &#39;E&#39; ? 1 : 0;
                }
                if(grid[i][j] == &#39;0&#39;)
                    max = Math.max(row + col[j], max);
            }
        }
        return max;
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;inorder-successor-in-bst:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Inorder Successor in BST&lt;/h1&gt;

&lt;p&gt;Given a binary search tree and a node in it, find the in-order successor of that node in the BST.&lt;/p&gt;

&lt;p&gt;Note: If the given node has no in-order successor in the tree, return null.&lt;/p&gt;

&lt;h2 id=&#34;solution-10:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;	//Iterative
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        TreeNode cur = root;
        TreeNode result = null;
        while(cur != null) {
            if(cur.val &amp;gt; p.val) {
                result = cur;
                cur = cur.left;
            } else {
                cur = cur.right;
            }
        }
        return result;
    }

	// Recursive
	public TreeNode successor(TreeNode root, TreeNode p) {
  		if (root == null)
    	return null;

  		if (root.val &amp;lt;= p.val) {
    		return successor(root.right, p);
  		} else {
    		TreeNode left = successor(root.left, p);
    		return (left != null) ? left : root;
  		}
	}	
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;find-the-celebrity:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Find the Celebrity&lt;/h1&gt;

&lt;p&gt;Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.&lt;/p&gt;

&lt;p&gt;Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: &amp;ldquo;Hi, A. Do you know B?&amp;rdquo; to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).&lt;/p&gt;

&lt;p&gt;You are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n), your function should minimize the number of calls to knows.&lt;/p&gt;

&lt;p&gt;Note: There will be exactly one celebrity if he/she is in the party. Return the celebrity&amp;rsquo;s label if there is a celebrity in the party. If there is no celebrity, return -1.&lt;/p&gt;

&lt;h2 id=&#34;solution-11:391bf8c2ccd1748d42853cd47f55ff11&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public int findCelebrity(int n) {
        if(n &amp;lt;= 1) return n-1;
        int cur = 0;
        for(int i = 1; i &amp;lt; n; i ++) {
            if(knows(cur, i)) {
                    cur = i;
            }
        }
        for(int i = 0; i &amp;lt; n; i ++) {
            if(i != cur &amp;amp;&amp;amp; (knows(cur, i) || !knows(i, cur)))
                return -1;
        }
        return cur;
    }

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Union Find for board connection</title>
      <link>http://yjn93.github.io/dev/UnionFind/</link>
      <pubDate>Tue, 03 Jan 2017 00:05:36 -0500</pubDate>
      
      <guid>http://yjn93.github.io/dev/UnionFind/</guid>
      <description>

&lt;h1 id=&#34;union-find:7b5dfc6ca8814f1e54ab64455253b7f0&#34;&gt;Union Find&lt;/h1&gt;

&lt;p&gt;This data structure can be used to solve dynamic connectivity problem. Usually, if we care about the path between two connected node, we need to use dfs. However, for checking the connectivity itself, union find can work. Also, dfs is suitable for static graph while union find is better for changing graph.&lt;/p&gt;

&lt;h2 id=&#34;initialization:7b5dfc6ca8814f1e54ab64455253b7f0&#34;&gt;Initialization&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;int[] unionSet;
// Initialize the union root of every element to be itself.
unionSet[i] = i;

// Sometime use another array to record the size of the union for the purpose of weighted union
int[] size = new int[unionSet.length];

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;weighted-union:7b5dfc6ca8814f1e54ab64455253b7f0&#34;&gt;Weighted Union&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    private void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
		if(size[rootP] &amp;lt; size[rootQ]) {
        	unionSet[rootP] = rootQ;
			size[rootQ] += size[rootP];
		} else {
			unionSet[rootQ] = rootP;
			size[rootP] += size[rootQ];
		}
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;find-with-path-compression:7b5dfc6ca8814f1e54ab64455253b7f0&#34;&gt;Find with path compression&lt;/h2&gt;

&lt;p&gt;Two ways: recursion and loop&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// recursion: set the height of the union to be 1
    private int find(int p) {
        if(unionSet[p] == p)
            return p;
        unionSet[p] = find(unionSet[p]);
        return unionSet[p];
    }

// loop: set the parent of a node to be its grandparent
    private int find(int p) {
        while(unionSet[p] != p){
           	unionSet[p] = unionSet[unionSet[p]];
			p = unionSet[p];
		}
        return p;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;surrounded-regions:7b5dfc6ca8814f1e54ab64455253b7f0&#34;&gt;Surrounded Regions&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/surrounded-regions/&#34;&gt;LeetCode 130&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given a 2D board containing &amp;lsquo;X&amp;rsquo; and &amp;lsquo;O&amp;rsquo; (the letter O), capture all regions surrounded by &amp;lsquo;X&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;A region is captured by flipping all &amp;lsquo;O&amp;rsquo;s into &amp;lsquo;X&amp;rsquo;s in that surrounded region.&lt;/p&gt;

&lt;h2 id=&#34;example:7b5dfc6ca8814f1e54ab64455253b7f0&#34;&gt;Example&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;X X X X
X O O X
X X O X
X O X X

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After running your function, the board should be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;X X X X
X X X X
X X X X
X O X X

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-with-union-find:7b5dfc6ca8814f1e54ab64455253b7f0&#34;&gt;Solution with union find&lt;/h2&gt;

&lt;p&gt;There is another solution which first use dfs from the edges to turn every edgeO to &amp;lsquo;1&amp;rsquo;, then turn every not-transfered &amp;lsquo;O&amp;rsquo; to &amp;lsquo;X&amp;rsquo;, then turn all &amp;lsquo;1&amp;rsquo; back to &amp;lsquo;O&amp;rsquo;. Here, we give the union find solution.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    int[] unionSet;
    boolean[] hasEdgeO;
    
    public void solve(char[][] board) {
        if(board == null || board.length == 0 || board[0].length == 0)
            return;
        int m = board.length, n = board[0].length;
        unionSet = new int[m * n];
        hasEdgeO = new boolean[unionSet.length];
        for(int i = 0; i &amp;lt; m; i ++) {
            for(int j = 0; j &amp;lt; n; j ++) {
                int index = i * n + j;
                unionSet[index] = index;
                if(board[i][j] == &#39;X&#39;) continue;
                if(i == 0 || j == 0 || i == m-1 || j == n-1)
                    hasEdgeO[index] = true;
                if(i &amp;gt; 0 &amp;amp;&amp;amp; board[i-1][j] == &#39;O&#39;)
                    union(index, index-n);
                if(j &amp;gt; 0 &amp;amp;&amp;amp; board[i][j-1] == &#39;O&#39;)
                    union(index, index-1);
            }
        }
        for(int i = 1; i &amp;lt; m; i ++) {
            for(int j = 1; j &amp;lt; n; j ++) {
                if(board[i][j] == &#39;O&#39; &amp;amp;&amp;amp; !hasEdgeO[find(i * n + j)])
                    board[i][j] = &#39;X&#39;;
            }   
        }
    }
    
    private int find(int p) {
        if(unionSet[p] == p)
            return p;
        unionSet[p] = find(unionSet[p]);
        return unionSet[p];
    }
    
    private void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        unionSet[rootP] = rootQ;
        hasEdgeO[rootQ] = hasEdgeO[rootP] || hasEdgeO[rootQ];
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;number-of-connected-components-in-an-undirected-graph:7b5dfc6ca8814f1e54ab64455253b7f0&#34;&gt;Number of Connected Components in an Undirected Graph&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/&#34;&gt;LeetCode 323&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.&lt;/p&gt;

&lt;h2 id=&#34;example-1:7b5dfc6ca8814f1e54ab64455253b7f0&#34;&gt;Example&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;	 0          3
     |          |
     1 --- 2    4
Given n = 5 and edges = [[0, 1], [1, 2], [3, 4]], return 2.

     0           4
     |           |
     1 --- 2 --- 3
Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]], return 1.

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-with-straitforward-dfs:7b5dfc6ca8814f1e54ab64455253b7f0&#34;&gt;Solution with straitforward dfs&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public int countComponents(int n, int[][] edges) {
        boolean[] visited = new boolean[n];
        List&amp;lt;Integer&amp;gt;[] adjs = new List[n];
        for(int i = 0; i &amp;lt; n; i ++)
            adjs[i] = new ArrayList();
        for(int[] edge: edges) {
            if(!adjs[edge[0]].contains(edge[1]))
                adjs[edge[0]].add(edge[1]);
            if(!adjs[edge[1]].contains(edge[0]))
                adjs[edge[1]].add(edge[0]);
        }
        int count = 0;
        for(int i = 0; i &amp;lt; n; i ++) {
            if(!visited[i]) {
                dfs(adjs, visited, i);
                count ++;
            }
        }
        return count;
    }
    
    public void dfs(List&amp;lt;Integer&amp;gt;[] adjs, boolean[] visited, int cur) {
        
        visited[cur] = true;
        for(int neighbor: adjs[cur])
            if(!visited[neighbor])
                dfs(adjs, visited, neighbor);
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-with-union-find-1:7b5dfc6ca8814f1e54ab64455253b7f0&#34;&gt;Solution with Union-Find&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public int countComponents(int n, int[][] edges) {
        int[] root = new int[n];
        for(int i = 0; i &amp;lt; n; i ++) {
            root[i] = i;
        }
        for(int[] edge: edges) {
            int i = find(root, edge[0]);
            int j = find(root, edge[1]);
            if(i != j) {
                root[i] = j;
                n --;
            }
        }
        return n;
    }
    
    public int find(int[] root, int p) {
        if(root[p] == p)
            return p;
        root[p] = find(root, root[p]);
        return root[p];
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;number-of-islands:7b5dfc6ca8814f1e54ab64455253b7f0&#34;&gt;Number of Islands&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/number-of-islands/&#34;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given a 2d grid map of &amp;lsquo;1&amp;rsquo;s (land) and &amp;lsquo;0&amp;rsquo;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.&lt;/p&gt;

&lt;h2 id=&#34;example-2:7b5dfc6ca8814f1e54ab64455253b7f0&#34;&gt;Example&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;11110
11010
11000
00000

Answer: 1

11000
11000
00100
00011

Answer: 3

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;dfs-solution:7b5dfc6ca8814f1e54ab64455253b7f0&#34;&gt;DFS solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public int numIslands(char[][] grid) {
        int count = 0;
        for(int i = 0; i &amp;lt; grid.length; i ++) {
            for(int j = 0; j &amp;lt; grid[0].length; j ++) {
                if(grid[i][j] == &#39;1&#39;) {
                    dfs(grid, i, j);
                    count ++;
                }
            }
        }
        return count;
    }
    
    public void dfs(char[][] grid, int i, int j) {
        if(i &amp;lt; 0 || j &amp;lt; 0 || i &amp;gt;= grid.length || j &amp;gt;= grid[0].length || grid[i][j] != &#39;1&#39; ) 
            return;
        grid[i][j] = &#39;0&#39;;
        dfs(grid, i-1, j);
        dfs(grid, i+1, j);
        dfs(grid, i, j-1);
        dfs(grid, i, j+1);
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;union-find-solution:7b5dfc6ca8814f1e54ab64455253b7f0&#34;&gt;Union-Find solution&lt;/h2&gt;

&lt;p&gt;2d version of the above connected components problem.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int numIslands(char[][] grid) {
        if(grid == null || grid.length == 0 || grid[0].length == 0)
            return 0;
        int count = 0;
        int m = grid.length, n = grid[0].length;
        int[] root = new int[m * n];
        for(int i = 0; i &amp;lt; m; i ++) {
            for(int j = 0; j &amp;lt; n; j ++) {
                if(grid[i][j] == &#39;1&#39;) {
                    count ++;
                }
                int index = i * n + j;
                root[index] = index;
            }
        }
        
        for(int i = 0; i &amp;lt; m; i ++) {
            for(int j = 0; j &amp;lt; n; j ++) {
                if(grid[i][j] == &#39;0&#39;) continue;
                int index = i * n + j;
                if(i &amp;gt; 0 &amp;amp;&amp;amp; grid[i-1][j] == &#39;1&#39;) {
                    int root1 = find(root, index);
                    int root2 = find(root, index-n);
                    if(root1 != root2) {
                        root[root1] = root2;
                        count --;
                    }
                }
                if(j &amp;gt; 0 &amp;amp;&amp;amp; grid[i][j-1] == &#39;1&#39;) {
                    int root1 = find(root, index);
                    int root2 = find(root, index-1);
                    if(root1 != root2) {
                        root[root1] = root2;
                        count --;
                    }
                }
            }
        }
        return count;
    }
    
    public int find(int[] root, int p) {
        if(root[p] == p) 
            return p;
        root[p] = find(root, root[p]);
        return root[p];
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;graph-valid-tree:7b5dfc6ca8814f1e54ab64455253b7f0&#34;&gt;Graph Valid Tree&lt;/h1&gt;

&lt;p&gt;Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;p&gt;Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true.&lt;/p&gt;

&lt;p&gt;Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.&lt;/p&gt;

&lt;h2 id=&#34;solution:7b5dfc6ca8814f1e54ab64455253b7f0&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;For the graph to be a tree, it should satisfy 2 conditions:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;There is no cycle.&lt;/li&gt;
&lt;li&gt;Every node is connected in the graph.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To check the first condition, we can use dfs or union find. If the first condition is satisfied, we can check the second one using the fact that number of edges in a tree = number of nodes - 1.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    int[] unionSet;
    public boolean validTree(int n, int[][] edges) {
        unionSet = new int[n];
        for(int i = 0; i &amp;lt; n; i ++) {
            unionSet[i] = i;
        }
        for(int[] edge: edges) {
            int x = find(edge[0]);
            int y = find(edge[1]);
            if(x == y)
                return false;
            unionSet[x] = y;
        }
        return edges.length == n - 1;
    }
    
    public int find(int x) {
        if(unionSet[x] == x)
            return x;
        unionSet[x] = find(unionSet[x]);
        return unionSet[x];
    }

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Contains Duplicate</title>
      <link>http://yjn93.github.io/dev/ContainsDuplicate/</link>
      <pubDate>Mon, 02 Jan 2017 11:02:39 -0500</pubDate>
      
      <guid>http://yjn93.github.io/dev/ContainsDuplicate/</guid>
      <description>

&lt;h1 id=&#34;contains-duplicate:a93a8fc10573dbdad791c81926e700b8&#34;&gt;Contains Duplicate&lt;/h1&gt;

&lt;p&gt;Given an array of integers, find if the array contains any duplicates.&lt;/p&gt;

&lt;p&gt;This is the basic problem. The solution is to use a set.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public boolean containsDuplicate(int[] nums) {
        Set&amp;lt;Integer&amp;gt; set = new HashSet();
        for(int num: nums) {
            if(!set.add(num))
                return true;
        }
        return false;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;contains-duplicate-within-a-window:a93a8fc10573dbdad791c81926e700b8&#34;&gt;Contains Duplicate within a window&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/contains-duplicate-ii/&#34;&gt;LeetCode 219&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.&lt;/p&gt;

&lt;h2 id=&#34;solution:a93a8fc10573dbdad791c81926e700b8&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;We can use a set or a hashmap. We only need to maintain the window size in for loop.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public boolean containsNearbyDuplicate(int[] nums, int k) {
        Set&amp;lt;Integer&amp;gt; set = new HashSet();
        for(int i = 0; i &amp;lt; nums.length; i ++) {
            if(!set.add(nums[i]))
                return true;
            if(i &amp;gt;= k)
                set.remove(nums[i-k]);
        }
        return false;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;contains-duplicate-in-a-range-within-a-window:a93a8fc10573dbdad791c81926e700b8&#34;&gt;Contains Duplicate in a range within a window&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/contains-duplicate-iii/&#34;&gt;LeetCode 220&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.&lt;/p&gt;

&lt;h2 id=&#34;treemap-solution:a93a8fc10573dbdad791c81926e700b8&#34;&gt;TreeMap solution&lt;/h2&gt;

&lt;p&gt;Instead of strict duplicate, there is now a constraint on the range of the values of the elements to be considered duplicates, it reminds us of doing a range check which is implemented in tree data structure and would take O(LogN) if a balanced tree structure is used.&lt;/p&gt;

&lt;p&gt;We can use Java TreeSet class. The floor and ceiling method can return the greatest and smallest element within a range in the set.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
        TreeSet&amp;lt;Integer&amp;gt; set = new TreeSet();
        for(int i = 0; i &amp;lt; nums.length; i ++) {
            Integer floor = set.floor(nums[i] + t);
            Integer ceiling = set.ceiling(nums[i] - t);
            if((floor != null &amp;amp;&amp;amp; floor &amp;gt;= nums[i]) || (ceiling != null &amp;amp;&amp;amp; ceiling &amp;lt;= nums[i]))
                return true;
            set.add(nums[i]);
            if(i &amp;gt;= k)
                set.remove(nums[i-k]);
        }
        return false;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bucket-solution:a93a8fc10573dbdad791c81926e700b8&#34;&gt;Bucket solution&lt;/h2&gt;

&lt;p&gt;This solution is doing constant time complexity.&lt;/p&gt;

&lt;p&gt;Notice: to avoid overflow, we need to use Long type.&lt;/p&gt;

&lt;p&gt;Another complication is that negative ints are allowed. A simple num / t just shrinks everything towards 0. Therefore, we can just reposition every element to start from Integer.MIN_VALUE.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
        if(k &amp;lt; 1 || t &amp;lt; 0) return false;
        Map&amp;lt;Long, Long&amp;gt; map = new HashMap();
        for(int i = 0; i &amp;lt; nums.length; i ++) {
            long newNum = (long)nums[i] - Integer.MIN_VALUE;
            long bucket = newNum/((long)t + 1);
            
            if(map.containsKey(bucket) || 
                map.containsKey(bucket-1) &amp;amp;&amp;amp; newNum - map.get(bucket-1) &amp;lt;= t ||
                map.containsKey(bucket+1) &amp;amp;&amp;amp; map.get(bucket+1) - newNum &amp;lt;= t)
                return true;
            map.put(bucket, newNum);
            if(i &amp;gt;= k) {
                long lastBucket = ((long)nums[i-k] - Integer.MIN_VALUE)/((long)t + 1);
                map.remove(lastBucket);
            }
        }
        return false;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Permutations</title>
      <link>http://yjn93.github.io/dev/Permutations/</link>
      <pubDate>Thu, 29 Dec 2016 16:03:10 -0500</pubDate>
      
      <guid>http://yjn93.github.io/dev/Permutations/</guid>
      <description>

&lt;h1 id=&#34;permutation:ae5fadc6fef33d3a20be0c4537ee7524&#34;&gt;Permutation&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/permutations/&#34;&gt;LeetCode 46&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given a collection of distinct numbers, return all possible permutations.&lt;/p&gt;

&lt;h2 id=&#34;backtracking-by-checking-whether-current-list-contains-an-element:ae5fadc6fef33d3a20be0c4537ee7524&#34;&gt;BackTracking by checking whether current list contains an element&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permute(int[] nums) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
        helper(result, new ArrayList(), nums);
        return result;
    }

    public void helper(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result, List&amp;lt;Integer&amp;gt; cur, int[] nums) {
        if(cur.size() == nums.length) {
            result.add(new ArrayList(cur));
            return;
        }
        for(int i = 0; i &amp;lt; nums.length; i ++) {
            if(cur.contains(nums[i])) continue;
            cur.add(nums[i]);
            helper(result, cur, nums);
            cur.remove(cur.size()-1);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;backtracking-with-swap:ae5fadc6fef33d3a20be0c4537ee7524&#34;&gt;BackTracking with swap&lt;/h2&gt;

&lt;p&gt;Try to put every element in current position&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permute(int[] nums) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
        helper(result, nums, 0);
        return result;
    }

    public void helper(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result, int[] nums, int start) {
        if(start == nums.length) {
            List&amp;lt;Integer&amp;gt; cur = new ArrayList();
            for(int num: nums)
                cur.add(num);
            result.add(cur);
            return;
        }
        for(int i = start; i &amp;lt; nums.length; i ++) {
            swap(nums, i, start);
            helper(result, nums, start+1);
            swap(nums, i, start);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;permutation-2:ae5fadc6fef33d3a20be0c4537ee7524&#34;&gt;Permutation 2&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/permutations-ii/&#34;&gt;LeetCode 47&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given a collection of numbers that might contain duplicates, return all possible unique permutations.&lt;/p&gt;

&lt;h2 id=&#34;example:ae5fadc6fef33d3a20be0c4537ee7524&#34;&gt;Example&lt;/h2&gt;

&lt;p&gt;[1,1,2] have the following unique permutations:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;backtracking-to-fulfill-current-list:ae5fadc6fef33d3a20be0c4537ee7524&#34;&gt;BackTracking to fulfill current list&lt;/h2&gt;

&lt;p&gt;Use an extra boolean array &amp;ldquo; boolean[] used&amp;rdquo; to indicate whether the value is added to list.&lt;/p&gt;

&lt;p&gt;Sort the array &amp;ldquo;int[] nums&amp;rdquo; to make sure we can skip the same value.&lt;/p&gt;

&lt;p&gt;when a number has the same value with its previous, we can use this number only if his previous is used&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permuteUnique(int[] nums) {
        Arrays.sort(nums);
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList();
        helper(result, new ArrayList(), nums, new boolean[nums.length]);
        return result;
    }

    public void helper(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result, List&amp;lt;Integer&amp;gt; cur, int[] nums, boolean[] used) {
        if(cur.size() == nums.length) {
            result.add(new ArrayList(cur));
            return;
        }
        for(int i = 0; i &amp;lt; nums.length; i ++) {
            if(used[i]) continue;
            if(i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i-1] &amp;amp;&amp;amp; !used[i-1]) continue;
            used[i] = true;
            cur.add(nums[i]);
            helper(result, cur, nums, used);
            cur.remove(cur.size()-1);
            used[i] = false;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;next-permutation:ae5fadc6fef33d3a20be0c4537ee7524&#34;&gt;Next Permutation&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/next-permutation/&#34;&gt;LeetCode 31&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.&lt;/p&gt;

&lt;p&gt;If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).&lt;/p&gt;

&lt;h2 id=&#34;solution:ae5fadc6fef33d3a20be0c4537ee7524&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public void nextPermutation(int[] nums) {
        int len = nums.length;
        if(len &amp;lt; 2) return;
        int index = len - 1;
        while(index &amp;gt; 0 &amp;amp;&amp;amp; nums[index] &amp;lt;= nums[index-1]) {
                index --;
        }
        if(index == 0) {
            reverse(nums, 0, len-1);
            return;
        }
        index --;
        int i = len-1;
        for(; i &amp;gt; 0; i --){
            if(nums[i] &amp;gt; nums[index])
                break;
        }
        swap(nums, index, i);
        reverse(nums, index+1, len-1);
    }

    public void reverse(int[] nums, int start, int end) {
        if(start &amp;gt;= end)
            return;
        for(int i = start; i &amp;lt;= (end+start)/2; i ++) {
            swap(nums, i, start+end-i);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;permutation-sequence:ae5fadc6fef33d3a20be0c4537ee7524&#34;&gt;Permutation Sequence&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/permutation-sequence/&#34;&gt;LeetCode 60&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The set [1,2,3,…,n] contains a total of n! unique permutations.&lt;/p&gt;

&lt;p&gt;By listing and labeling all of the permutations in order,
We get the following sequence (ie, for n = 3):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. &amp;quot;123&amp;quot;
2. &amp;quot;132&amp;quot;
3. &amp;quot;213&amp;quot;
4. &amp;quot;231&amp;quot;
5. &amp;quot;312&amp;quot;
6. &amp;quot;321&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Given n and k, return the kth permutation sequence.&lt;/p&gt;

&lt;h2 id=&#34;solution-1:ae5fadc6fef33d3a20be0c4537ee7524&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public String getPermutation(int n, int k) {
        int[] factorial = new int[n+1];
        factorial[0] = 1;
        int sum = 1;
        List&amp;lt;Integer&amp;gt; nums = new ArrayList();
        for(int i = 1; i &amp;lt;= n; i ++) {
            sum *= i;
            factorial[i] = sum;
            nums.add(i);
        }
        
        k --;
        StringBuilder sb = new StringBuilder();
        for(int i = 1; i &amp;lt;= n; i ++) {
            int index = k/factorial[n-i];
            sb.append(nums.get(index));
            nums.remove(index);
            k -= index*factorial[n-i];
        }
        return sb.toString();
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>hIndex</title>
      <link>http://yjn93.github.io/dev/hIndex/</link>
      <pubDate>Sat, 24 Dec 2016 21:26:42 -0500</pubDate>
      
      <guid>http://yjn93.github.io/dev/hIndex/</guid>
      <description>

&lt;h1 id=&#34;h-index:37408efcd60dda986ed9231afcc7821f&#34;&gt;H Index&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/h-index/&#34;&gt;LeetCode 274&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher&amp;rsquo;s h-index.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;For example, given citations = [3, 0, 6, 1, 5], which means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, his h-index is 3.&lt;/p&gt;

&lt;h2 id=&#34;solution:37408efcd60dda986ed9231afcc7821f&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;Use bucket sort. Suppose we have len papers, then h-index cannot exceed len, so we can create len+1 buckets. Each bucket stores the number of papers that have the according citation. Then we iterate from the back to the front of the buckets, whenever the total count exceeds the index of the bucket, meaning that we have the index number of papers that have reference greater than or equal to the index. Which will be our h-index result. The reason to scan from the end of the array is that we are looking for the greatest h-index.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int hIndex(int[] citations) {

        int len = citations.length;

        int[] bucket = new int[len+1];

        for(int c: citations) {

            if(c &amp;gt; len) bucket[len] ++;

            else bucket[c] ++;

        }

        int index = 0;

        for(int i = len; i &amp;gt;= 0; i --) {

            index += bucket[i];

            if(index &amp;gt;= i)

                return i;

        }

        return 0;

    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Wiggle Subsequence</title>
      <link>http://yjn93.github.io/dev/WiggleSequence/</link>
      <pubDate>Sat, 24 Dec 2016 19:38:38 -0500</pubDate>
      
      <guid>http://yjn93.github.io/dev/WiggleSequence/</guid>
      <description>

&lt;h1 id=&#34;wiggle-subsequence:5a249ba779613037888e50c3f36770e8&#34;&gt;Wiggle Subsequence&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/wiggle-subsequence/&#34;&gt;LeetCode 376&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.&lt;/p&gt;

&lt;h2 id=&#34;example:5a249ba779613037888e50c3f36770e8&#34;&gt;Example&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Input: [1,7,4,9,2,5]
Output: 6
The entire sequence is a wiggle sequence.

Input: [1,17,5,10,13,15,10,5,16,8]
Output: 7
There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].

Input: [1,2,3,4,5,6,7,8,9]
Output: 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution:5a249ba779613037888e50c3f36770e8&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;Use two variable up and down to track current maximum length of subsequence that end with up and down respectively.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int wiggleMaxLength(int[] nums) {

        if(nums.length &amp;lt; 2) return nums.length;

        int up = 1, down = 1;

        for(int i = 1; i &amp;lt; nums.length; i ++) {

            if(nums[i] &amp;gt; nums[i-1])

                up = down + 1;

            else if (nums[i] &amp;lt; nums[i-1])

                down = up + 1;

        }

        return Math.max(up, down);

    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>GuessNumber</title>
      <link>http://yjn93.github.io/dev/GuessNumber/</link>
      <pubDate>Sat, 24 Dec 2016 13:02:42 -0500</pubDate>
      
      <guid>http://yjn93.github.io/dev/GuessNumber/</guid>
      <description>

&lt;h1 id=&#34;guess-number-higher-or-lower-ii:d06f8d361b54867e9a90313f9c7e4037&#34;&gt;Guess Number Higher or Lower II&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/guess-number-higher-or-lower-ii/&#34;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We are playing the Guess Game. The game is as follows:&lt;/p&gt;

&lt;p&gt;I pick a number from 1 to n. You have to guess which number I picked.&lt;/p&gt;

&lt;p&gt;Every time you guess wrong, I&amp;rsquo;ll tell you whether the number I picked is higher or lower.&lt;/p&gt;

&lt;p&gt;However, when you guess a particular number x, and you guess wrong, you pay $x. You win the game when you guess the number I picked.&lt;/p&gt;

&lt;h2 id=&#34;example:d06f8d361b54867e9a90313f9c7e4037&#34;&gt;Example&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;n = 10, I pick 8.

First round:  You guess 5, I tell you that it&#39;s higher. You pay $5.
Second round: You guess 7, I tell you that it&#39;s higher. You pay $7.
Third round:  You guess 9, I tell you that it&#39;s lower. You pay $9.

Game over. 8 is the number I picked.

You end up paying $5 + $7 + $9 = $21.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution:d06f8d361b54867e9a90313f9c7e4037&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;For each number x in range[i~j]&lt;/p&gt;

&lt;p&gt;we do: result_when_pick_x = x + max{DP([i~x-1]), DP([x+1, j])}&lt;/p&gt;

&lt;p&gt;&amp;ndash;&amp;gt; // the max means whenever you choose a number, the feedback is always bad and therefore leads you to a worse branch.&lt;/p&gt;

&lt;p&gt;then we get DP([i~j]) = min{xi, &amp;hellip; ,xj}&lt;/p&gt;

&lt;p&gt;&amp;ndash;&amp;gt; // this min makes sure that you are minimizing your cost.&lt;/p&gt;

&lt;h3 id=&#34;recursive-dp:d06f8d361b54867e9a90313f9c7e4037&#34;&gt;Recursive DP&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    public int getMoneyAmount(int n) {
        int[][] table = new int[n+1][n+1];
        return dp(table, 1, n);
    }
    
    public int dp(int[][] table, int start, int end) {
        if(start &amp;gt;= end) return 0;
        if(table[start][end] != 0) return table[start][end];
        int result = Integer.MAX_VALUE;
        for(int k = start; k &amp;lt;= end; k ++) {
            result = Math.min(result, k + Math.max(dp(table, start, k-1), dp(table, k+1, end)));
        }
        table[start][end] = result;
        return result;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;bottom-up-dp:d06f8d361b54867e9a90313f9c7e4037&#34;&gt;Bottom-up DP&lt;/h3&gt;

&lt;p&gt;Fill the table&amp;rsquo;s every column. For each column, it represents the up limit of the range, and we should fill the column from (j-1, j) to (1, j).&lt;/p&gt;

&lt;p&gt;Because for example, if i == 1, j == 5, when k = 3, we need table[4][5] be exist.&lt;/p&gt;

&lt;p&gt;Also notice the base case is when i + 1 == j, we choose i over j.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int getMoneyAmount(int n) {
        int[][] table = new int[n+1][n+1];
        for(int j = 2; j &amp;lt;= n; j ++) {
            for(int i=j-1; i&amp;gt;0; i--) {
                int globalMin = Integer.MAX_VALUE;
                for(int k = i + 1; k &amp;lt; j; k ++) {
                    int localMax = k + Math.max(table[i][k-1], table[k+1][j]);
                    globalMin = Math.min(globalMin, localMax);
                }
                table[i][j] = i + 1 == j ? i : globalMin;
            }
        }
        return table[1][n];
    }

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>TwoPointers</title>
      <link>http://yjn93.github.io/dev/TwoPointers/</link>
      <pubDate>Fri, 23 Dec 2016 11:06:24 -0500</pubDate>
      
      <guid>http://yjn93.github.io/dev/TwoPointers/</guid>
      <description>

&lt;h1 id=&#34;container-with-most-water:c2e5aab05fc3611299f5587d4afa2c58&#34;&gt;Container With Most Water&lt;/h1&gt;

&lt;p&gt;-&lt;a href=&#34;https://leetcode.com/problems/container-with-most-water/&#34;&gt;LeetCode 11&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Given n non-negative integers a1, a2, &amp;hellip;, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.&lt;/p&gt;

&lt;h2 id=&#34;sample:c2e5aab05fc3611299f5587d4afa2c58&#34;&gt;Sample&lt;/h2&gt;

&lt;p&gt;Reference from LeetCode top solution.&lt;/p&gt;

&lt;p&gt;Draw a matrix where the row is the first line, and the column is the second line. For example, say n=6.&lt;/p&gt;

&lt;p&gt;In the figures below, x means we don&amp;rsquo;t need to compute the volume for that case: (1) On the diagonal, the two lines are overlapped; (2) The lower left triangle area of the matrix is symmetric to the upper right area.&lt;/p&gt;

&lt;p&gt;We start by computing the volume at (1,6), denoted by o. Now if the left line is shorter than the right line, then all the elements left to (1,6) on the first row have smaller volume, so we don&amp;rsquo;t need to compute those cases (crossed by &amp;mdash;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;		  1 2 3 4 5 6
		1 x ------- o
		2 x x
		3 x x x 
		4 x x x x
		5 x x x x x
		6 x x x x x x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we move the left line and compute (2,6). Now if the right line is shorter, all cases below (2,6) are eliminated.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;		  1 2 3 4 5 6
		1 x ------- o
		2 x x       o
		3 x x x     |
		4 x x x x   |
		5 x x x x x |
		6 x x x x x x

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And no matter how this o path goes, we end up only need to find the max value on this path, which contains n-1 cases.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;		  1 2 3 4 5 6
		1 x ------- o
		2 x x - o o o
		3 x x x o | |
		4 x x x x | |
		5 x x x x x |
		6 x x x x x x
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution:c2e5aab05fc3611299f5587d4afa2c58&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public int maxArea(int[] height) {
        int left = 0, right = height.length-1;
        int max = 0;
        while(left &amp;lt; right) {
            max = Math.max(max, Math.min(height[left], height[right]) * (right - left));
            if(height[left] &amp;lt; height[right])
                left ++;
            else 
                right --;
        }
        return max;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;sort-colors:c2e5aab05fc3611299f5587d4afa2c58&#34;&gt;Sort Colors&lt;/h1&gt;

&lt;p&gt;-&lt;a href=&#34;https://leetcode.com/problems/sort-colors/&#34;&gt;LeetCode 75&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.&lt;/p&gt;

&lt;p&gt;Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.&lt;/p&gt;

&lt;h2 id=&#34;solution-1:c2e5aab05fc3611299f5587d4afa2c58&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public void sortColors(int[] nums) {
        int left = 0, right = nums.length - 1;
        for(int i = 0; i &amp;lt;= right; i ++) {
            while(nums[i] == 2 &amp;amp;&amp;amp; i &amp;lt; right)
                swap(nums, i, right --);
            while(nums[i] == 0 &amp;amp;&amp;amp; i &amp;gt; left) 
                swap(nums, i, left ++);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>RotateMatrix</title>
      <link>http://yjn93.github.io/dev/RotateMatrix/</link>
      <pubDate>Thu, 22 Dec 2016 13:15:37 -0500</pubDate>
      
      <guid>http://yjn93.github.io/dev/RotateMatrix/</guid>
      <description>

&lt;h1 id=&#34;rotate-image:18934d05988ea6297312db56d76fae0e&#34;&gt;Rotate Image&lt;/h1&gt;

&lt;p&gt;You are given an n x n 2D matrix representing an image.&lt;/p&gt;

&lt;p&gt;Rotate the image by 90 degrees (clockwise).&lt;/p&gt;

&lt;h2 id=&#34;trick:18934d05988ea6297312db56d76fae0e&#34;&gt;Trick&lt;/h2&gt;

&lt;p&gt;I did the rotation in a dummy way. There is a trick:&lt;/p&gt;

&lt;p&gt;The idea was firstly transpose the matrix and then flip it symmetrically.&lt;/p&gt;

&lt;h2 id=&#34;sample:18934d05988ea6297312db56d76fae0e&#34;&gt;Sample&lt;/h2&gt;

&lt;p&gt;Transpose: swap(matrix[i][j], matrix[j][i])&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1  2  3             
4  5  6
7  8  9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then flip the matrix horizontally. (swap(matrix[i][j], matrix[i][matrix.length-1-j])&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;7  4  1
8  5  2
9  6  3

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution:18934d05988ea6297312db56d76fae0e&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public void rotate(int[][] matrix) {
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0)
            return;
        int len = matrix.length;
        for(int i = 0; i &amp;lt; len; i ++) {
            for(int j = i + 1; j &amp;lt; len; j ++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        for(int i = 0; i &amp;lt; len; i ++) {
            for(int j = 0; j &amp;lt; len/2; j ++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[i][len - j - 1];
                matrix[i][len - j - 1] = temp;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Knapsack</title>
      <link>http://yjn93.github.io/dev/Knapsack/</link>
      <pubDate>Wed, 21 Dec 2016 12:19:33 -0500</pubDate>
      
      <guid>http://yjn93.github.io/dev/Knapsack/</guid>
      <description>

&lt;h1 id=&#34;knapsack-problem:c06120d33a3798cdda1b16554d032ce1&#34;&gt;Knapsack problem&lt;/h1&gt;

&lt;p&gt;Given weights (wt[i]) and values (val[i]) of n items, put these items in a knapsack of capacity W to get the maximum total value in the knapsack.&lt;/p&gt;

&lt;h2 id=&#34;basic-dp:c06120d33a3798cdda1b16554d032ce1&#34;&gt;Basic dp&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;K[i][v]=max{K[i-1][v],K[i-1][v-wt[i]]+val[i]}

int knapSack(int W, int wt[], int val[], int n)
{
   int i, w;
   int K[n+1][W+1];
 
   // Build table K[][] in bottom up manner
   for (i = 0; i &amp;lt;= n; i++)
   {
       for (w = 0; w &amp;lt;= W; w++)
       {
           if (i==0 || w==0)
               K[i][w] = 0;
           else if (wt[i-1] &amp;lt;= w)
                 K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]],  K[i-1][w]);
           else
                 K[i][w] = K[i-1][w];
       }
   }
 
   return K[n][W];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;space-optimization:c06120d33a3798cdda1b16554d032ce1&#34;&gt;Space optimization&lt;/h2&gt;

&lt;p&gt;To make sure in ith loop, K[v-wt[i]] stores previous K[i-1][v-wt[i]], the inner for loop should index in decreasing order.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i = 1 .. N
	for v = W .. 0
		K[v]=max{K[v],K[v-wt[i]]+val[i]}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;partition-equal-subset-sum:c06120d33a3798cdda1b16554d032ce1&#34;&gt;Partition Equal Subset Sum&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/partition-equal-subset-sum/&#34;&gt;LeetCode 416&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.&lt;/p&gt;

&lt;h2 id=&#34;example:c06120d33a3798cdda1b16554d032ce1&#34;&gt;Example:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Input: [1, 5, 11, 5]

Output: true

Explanation: The array can be partitioned as [1, 5, 5] and [11].

Input: [1, 2, 3, 5]

Output: false

Explanation: The array cannot be partitioned into equal sum subsets.

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution:c06120d33a3798cdda1b16554d032ce1&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public boolean canPartition(int[] nums) {
        int sum = 0;
        for(int num: nums) {
            sum += num;
        }
        if(sum % 2 != 0) return false;
        sum /= 2;
        boolean[] dp = new boolean[sum + 1];
        dp[0] = true;
        for(int i = 0; i &amp;lt; nums.length; i ++) {
            for(int j = sum; j &amp;gt;= nums[i]; j --) {
                dp[j] = dp[j] || dp[j - nums[i]];
            }
        }
        
        return dp[sum];
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>QuickSort</title>
      <link>http://yjn93.github.io/dev/QuickSort/</link>
      <pubDate>Wed, 21 Dec 2016 09:59:54 -0500</pubDate>
      
      <guid>http://yjn93.github.io/dev/QuickSort/</guid>
      <description>

&lt;h1 id=&#34;kth-largest-element-in-an-array:423f35d8021d43f6473e42ba8f0642fc&#34;&gt;Kth Largest Element in an Array&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/kth-largest-element-in-an-array/&#34;&gt;LeetCode 215&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Find the kth largest element in an unsorted array.&lt;/p&gt;

&lt;h2 id=&#34;example:423f35d8021d43f6473e42ba8f0642fc&#34;&gt;Example&lt;/h2&gt;

&lt;p&gt;Given [3,2,1,5,6,4] and k = 2, return 5.&lt;/p&gt;

&lt;h2 id=&#34;solution:423f35d8021d43f6473e42ba8f0642fc&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;Quickselect, using quicksort idea. Two implementation of quicksort:&lt;/p&gt;

&lt;h3 id=&#34;first-implementation-of-partition:423f35d8021d43f6473e42ba8f0642fc&#34;&gt;First implementation of partition:&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    public int partition(int[] nums, int start, int end) {
        int pivot = nums[start];
        int left = start, right = end+1;
        while(true) {
            while(left &amp;lt; end &amp;amp;&amp;amp; nums[++ left] &amp;lt; pivot);
            while(start &amp;lt; right &amp;amp;&amp;amp; nums[-- right] &amp;gt; pivot );
            if(left &amp;lt; right) swap(nums, left, right);
            else break;
        }
        swap(nums, start, right);
        return right;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;second-implementation-of-partition:423f35d8021d43f6473e42ba8f0642fc&#34;&gt;Second implementation of partition:&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    public int partition(int[] nums, int lo, int hi) {
    	int left = lo, right = hi, pivot = a[hi];
    	while (left &amp;lt; right) {
	      if (a[left++] &amp;gt; pivot) swap(a, --`left, -- right);
    	}
    	swap(a, left, hi);
		return left;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;complete-solution:423f35d8021d43f6473e42ba8f0642fc&#34;&gt;Complete Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    public int findKthLargest(int[] nums, int k) {
        k = nums.length - k;
        int lo = 0, hi = nums.length-1;
        while(lo &amp;lt; hi) {
            int split = partition(nums, lo, hi);
            if(split &amp;lt; k) lo = split+1;
            else if(split &amp;gt; k) hi = split - 1;
            else break;
        }
        return nums[k];
    }
    
    public int partition(int[] nums, int start, int end) {
        int pivot = nums[start];
        int left = start, right = end+1;
        while(true) {
            while(left &amp;lt; end &amp;amp;&amp;amp; nums[++ left] &amp;lt; pivot);
            while(start &amp;lt; right &amp;amp;&amp;amp; nums[-- right] &amp;gt; pivot );
            if(left &amp;lt; right) swap(nums, left, right);
            else break;
        }
        swap(nums, start, right);
        return right;
    }
    
    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Combination Sum</title>
      <link>http://yjn93.github.io/dev/Combination_Sum/</link>
      <pubDate>Sat, 26 Nov 2016 10:30:22 -0500</pubDate>
      
      <guid>http://yjn93.github.io/dev/Combination_Sum/</guid>
      <description>

&lt;h1 id=&#34;combination-sum-3:7a055b9f53e64947361af5747bddcbb5&#34;&gt;Combination Sum 3&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/combination-sum-iii/&#34;&gt;LeetCode 216&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.&lt;/p&gt;

&lt;h2 id=&#34;example:7a055b9f53e64947361af5747bddcbb5&#34;&gt;Example&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;k = 3, n = 7
[[1,2,4]]

k = 3, n = 9
[[1,2,6], [1,3,5], [2,3,4]]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution:7a055b9f53e64947361af5747bddcbb5&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;BackTracking&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum3(int k, int n) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
        helper(result, new ArrayList&amp;lt;Integer&amp;gt;(), k, n, 1);
        return result;
    }
    
    public void helper(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result, List&amp;lt;Integer&amp;gt; cur, int k, int n, int start) {
        if(k == 0 &amp;amp;&amp;amp; n == 0) {
            result.add(new ArrayList(cur));
            return;
        }
        if(k == 0 || start &amp;gt; n) return;
        for(int i = start; i &amp;lt;= 9 &amp;amp;&amp;amp; i &amp;lt;= n ; i ++) {
            cur.add(i);
            helper(result, cur, k-1, n-i, i+1);
            cur.remove(cur.size()-1);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;combination-sum-4:7a055b9f53e64947361af5747bddcbb5&#34;&gt;Combination Sum 4&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/combination-sum-iv/&#34;&gt;LeetCode 377&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.&lt;/p&gt;

&lt;h2 id=&#34;example-1:7a055b9f53e64947361af5747bddcbb5&#34;&gt;Example:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;nums = [1, 2, 3]
target = 4

The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

Note that different sequences are counted as different combinations.

Therefore the output is 7.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-1:7a055b9f53e64947361af5747bddcbb5&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;I used recursive solution first, but raised Time Limit Exceeded. This problem actually can be solve in DP because we only need to calculate the possible combinations for a subTarget once.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target+1];
        dp[0] = 1;
        for(int i = 1; i &amp;lt;= target; i ++) {
            for(int j = 0; j &amp;lt; nums.length; j ++) {
                if(i - nums[j] &amp;gt;= 0)
                    dp[i] += dp[i-nums[j]];
            }
        }
        return dp[target];
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Buy and Sell Stocks</title>
      <link>http://yjn93.github.io/dev/Buy_and_Sell_Stocks/</link>
      <pubDate>Fri, 18 Nov 2016 09:54:11 -0500</pubDate>
      
      <guid>http://yjn93.github.io/dev/Buy_and_Sell_Stocks/</guid>
      <description>

&lt;h1 id=&#34;one-transaction:bc34b67cdae43a991edbce9949a535fb&#34;&gt;One transaction&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/best-time-to-buy-and-sell-stock/&#34;&gt;LeetCode 121&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:bc34b67cdae43a991edbce9949a535fb&#34;&gt;Solution&lt;/h2&gt;

&lt;h3 id=&#34;my-approach:bc34b67cdae43a991edbce9949a535fb&#34;&gt;My approach&lt;/h3&gt;

&lt;p&gt;Track the min value, update the maxProfit.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int maxProfit(int[] prices) {
        int min = Integer.MAX_VALUE;
        int max = 0;
        for(int price: prices) {
            min = Math.min(min, price);
            max = Math.max(max, price-min);
        }
        return max;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;kadane-s-algorithm-solution:bc34b67cdae43a991edbce9949a535fb&#34;&gt;Kadane&amp;rsquo;s Algorithm Solution&lt;/h3&gt;

&lt;p&gt;Kadane&amp;rsquo;s Algorithm is used to solve Maximum Subarray problem
Here, the logic is to calculate the difference (maxCur += prices[i] - prices[i-1]) of the original array, and find a contiguous subarray giving maximum profit. If the difference falls below 0, reset it to zero.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int maxProfit(int[] prices) {
        int curMax = 0;
        int max = 0;
        for(int i = 1; i &amp;lt; prices.length; i ++) {
            curMax = Math.max(0, curMax+prices[i]-prices[i-1]);
            max = Math.max(max, curMax);
        }
        return max;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;maximum-subarray-problem:bc34b67cdae43a991edbce9949a535fb&#34;&gt;Maximum Subarray Problem&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/maximum-subarray/&#34;&gt;LeetCode 53&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;example:bc34b67cdae43a991edbce9949a535fb&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum = 6.&lt;/p&gt;

&lt;h3 id=&#34;solution-1:bc34b67cdae43a991edbce9949a535fb&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;Using Kadane&amp;rsquo;s algorithm, which consists of a scan through the array values, computing at each position the maximum (positive sum) subarray ending at that position. This subarray is either empty (in which case its sum is zero) or consists of one more element than the maximum subarray ending at the previous position.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int maxSubArray(int[] nums) {
        int max = Integer.MIN_VALUE;
        int leftMax = 0;
        for(int num: nums) {
            max = Math.max(max, leftMax+num);
            leftMax = Math.max(0, leftMax+num);
        }
        return max;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;notice:bc34b67cdae43a991edbce9949a535fb&#34;&gt;Notice&lt;/h3&gt;

&lt;p&gt;The corner case: all elements are negative.&lt;/p&gt;

&lt;h1 id=&#34;many-transactions:bc34b67cdae43a991edbce9949a535fb&#34;&gt;Many transactions&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/&#34;&gt;LeetCode 122&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;peak-and-valley-approach:bc34b67cdae43a991edbce9949a535fb&#34;&gt;Peak and Valley approach&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public int maxProfit(int[] prices) {
        int result = 0;
        int idx = 0;
        while(idx &amp;lt; prices.length-1) {
            while(idx+1 &amp;lt; prices.length &amp;amp;&amp;amp; prices[idx+1] &amp;lt;= prices[idx])
                idx ++;
            int low = prices[idx];
            while(idx+1 &amp;lt; prices.length &amp;amp;&amp;amp; prices[idx+1] &amp;gt;= prices[idx])
                idx ++;
            result += prices[idx]-low;
            idx ++;
        }
        return result;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;simple-one-pass:bc34b67cdae43a991edbce9949a535fb&#34;&gt;Simple one pass&lt;/h2&gt;

&lt;p&gt;we can directly keep on adding the difference between the consecutive numbers of the array if the second number is larger than the first one, and at the total sum we obtain will be the maximum profit.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int maxProfit(int[] prices) {
        int max = 0;
        for(int i = 1; i &amp;lt; prices.length; i ++) {
            if(prices[i] &amp;gt; prices[i-1])
                max += prices[i]-prices[i-1];
        }
        return max;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;multiple-transactions-with-cooldown:bc34b67cdae43a991edbce9949a535fb&#34;&gt;Multiple transactions with cooldown&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/&#34;&gt;LeetCode 309&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;example-1:bc34b67cdae43a991edbce9949a535fb&#34;&gt;Example&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;prices = [1, 2, 3, 0, 2]
maxProfit = 3
transactions = [buy, sell, cooldown, buy, sell]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-2:bc34b67cdae43a991edbce9949a535fb&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;Dynamic programming: tracking the maxProfit for ending with sell and buy&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;buy[i] = max(sell[i-2]-price, buy[i-1])
sell[i] = max(buy[i-1]+price, sell[i-1])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Can reduce the space:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;preBuy = curBuy;
curBuy = max(preSell-num, preBuy);
preSell = curSell;
curSell = max(preBuy+num, preSell);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java code&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int maxProfit(int[] prices) {
        int preSell = 0, curSell = 0;
		int curBuy = Integer.MIN_VALUE, preBuy;
        for(int price: prices) {
            preBuy = curBuy;
            curBuy = Math.max(preSell - price, preBuy);
            preSell = curSell;
            curSell = Math.max(preBuy + price, preSell);
        }
        return curSell;
    }

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Bit Manipulation</title>
      <link>http://yjn93.github.io/dev/Bit-Manipulation/</link>
      <pubDate>Sun, 13 Nov 2016 10:46:27 -0500</pubDate>
      
      <guid>http://yjn93.github.io/dev/Bit-Manipulation/</guid>
      <description>

&lt;h1 id=&#34;clever-tricks:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Clever Tricks&lt;/h1&gt;

&lt;h3 id=&#34;get-the-rightmost-set-bit:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Get the rightmost set bit&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;	num &amp;amp;= -num;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;set-the-rightmost-1-to-0:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Set the rightmost 1 to 0&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;	num &amp;amp;= (num-1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;facts:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Facts&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;~(num-1) == -num&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;single-number-iii:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Single Number III&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/single-number-iii/&#34;&gt;LeetCode 260&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.&lt;/p&gt;

&lt;h2 id=&#34;example:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Example:&lt;/h2&gt;

&lt;p&gt;Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].&lt;/p&gt;

&lt;h2 id=&#34;solution:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;In the first pass of for loop, we XOR all elements in the array, and get the XOR of the two numbers we need to find.&lt;/p&gt;

&lt;p&gt;The second pass is hard to come up with, we use the trick in the first session to get the rightmost set bit of the XOR of the two target number. We can divide all elements in two groups, and the target two numbers will fall into different groups.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int[] singleNumber(int[] nums) {
        int diff = 0;
        for(int num: nums) {
            diff ^= num;
        }
        diff &amp;amp;= -diff;
        int[] result = {0,0};
        for(int num: nums) {
            if((num &amp;amp; diff) == 0)
                result[0] ^= num;
            else
                result[1] ^= num;
        }
        return result;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;single-number-ii:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Single Number II&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/single-number-ii/&#34;&gt;LeetCode 137&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given an array of integers, every element appears three times except for one. Find that single one.&lt;/p&gt;

&lt;h2 id=&#34;solution-1:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public int singleNumber(int[] nums) {
        int ones = 0, twos = 0;
        for(int num: nums) {
            ones = (ones ^ num) &amp;amp; ~twos;
            twos = (twos ^ num) &amp;amp; ~ones;
        }
        return ones;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;missing-number:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Missing Number&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/missing-number/&#34;&gt;LeetCode 268&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given an array containing n distinct numbers taken from 0, 1, 2, &amp;hellip;, n, find the one that is missing from the array.&lt;/p&gt;

&lt;h2 id=&#34;example-1:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Example&lt;/h2&gt;

&lt;p&gt;Given nums = [0, 1, 3] return 2.&lt;/p&gt;

&lt;h2 id=&#34;solution-2:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public int missingNumber(int[] nums) {
        int result = nums.length;
        for(int i = 0; i &amp;lt; nums.length; i ++) {
            result ^= i;
            result ^= nums[i];
        }
        return result;
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;integer-replacement:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Integer Replacement&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/integer-replacement/&#34;&gt;LeetCode 397&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given a positive integer n and you can do operations as follow:&lt;/p&gt;

&lt;p&gt;If n is even, replace n with n/2.&lt;/p&gt;

&lt;p&gt;If n is odd, you can replace n with either n + 1 or n - 1.&lt;/p&gt;

&lt;p&gt;What is the minimum number of replacements needed for n to become 1?&lt;/p&gt;

&lt;h2 id=&#34;example-2:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Example&lt;/h2&gt;

&lt;p&gt;Input: 8&lt;/p&gt;

&lt;p&gt;Output: 3&lt;/p&gt;

&lt;p&gt;Explanation: 8 -&amp;gt; 4 -&amp;gt; 2 -&amp;gt; 1&lt;/p&gt;

&lt;p&gt;Input: 7&lt;/p&gt;

&lt;p&gt;Output: 4&lt;/p&gt;

&lt;p&gt;Explanation: 7 -&amp;gt; 8 -&amp;gt; 4 -&amp;gt; 2 -&amp;gt; 1 or 7 -&amp;gt; 6 -&amp;gt; 3 -&amp;gt; 2 -&amp;gt; 1&lt;/p&gt;

&lt;h2 id=&#34;solution-3:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;Recursion will cause StackOverFlow. There are two ways for this problem. One uses iteration, one use bit manipulation.&lt;/p&gt;

&lt;h3 id=&#34;iteration:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Iteration&lt;/h3&gt;

&lt;p&gt;When n is odd it can be written into the form n = 2k+1 (k is a non-negative integer.). That is, n+1 = 2k+2 and n-1 = 2k. Then, (n+1)/2 = k+1 and (n-1)/2 = k. So one of (n+1)/2 and (n-1)/2 is even, the other is odd. And the &amp;ldquo;best&amp;rdquo; case of this problem is to divide as much as possible. Because of that, always pick n+1 or n-1 based on if it can be divided by 4. The only special case of that is when n=3 you would like to pick n-1 rather than n+1.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int integerReplacement(int n) {
        if(n == Integer.MAX_VALUE) return 32;
        int count = 0;
        while(n != 1) {
            if(n % 2 == 0) {
                n /= 2;
            } else {
                if((n + 1) % 4 == 0 &amp;amp;&amp;amp; n != 3)
                    n += 1;
                else
                    n -= 1;
            }
            count ++;
        }
        return count;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;bit-manipulation:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Bit Manipulation&lt;/h3&gt;

&lt;p&gt;We can use the same idea to do bit manipulation. When n is odd, we only need to check the last two bits of n. If the second least significant bit is 1, then increase n by 1, unless n is 3.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int integerReplacement(int n) {
        int count = 0;
        while(n != 1) {
            if(n % 2 == 0)
                n &amp;gt;&amp;gt;&amp;gt;= 1;
            else if(n == 3 || ((n &amp;gt;&amp;gt;&amp;gt; 1) &amp;amp; 1) == 0)
                n --;
            else 
                n ++;
            count ++;
        }
        return count;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;subsets:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Subsets&lt;/h1&gt;

&lt;p&gt;Given a set of distinct integers, nums, return all possible subsets.&lt;/p&gt;

&lt;p&gt;Note: The solution set must not contain duplicate subsets.&lt;/p&gt;

&lt;p&gt;For example,
If nums = [1,2,3], a solution is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;backtracking-solution:3344d83625fb333615fef7b8a8bdad05&#34;&gt;BackTracking Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsets(int[] nums) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
        backTracking(result, new ArrayList&amp;lt;Integer&amp;gt;(), nums, 0);
        return result;
    }
    
    public void backTracking(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result, List&amp;lt;Integer&amp;gt; subset, int[] nums, int start) {
        result.add(new ArrayList&amp;lt;Integer&amp;gt;(subset));
        for(int i = start; i &amp;lt; nums.length; i ++) {
            subset.add(nums[i]);
            backTracking(result, subset, nums, i+1);
            subset.remove(subset.size()-1);
        }
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bit-manipulation-solution:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Bit Manipulation Solution&lt;/h2&gt;

&lt;p&gt;We can take or not take an element, so we can represent one subset as a unique state sequence.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsets(int[] nums) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
        int total = 1 &amp;lt;&amp;lt; nums.length;
        for(int i = 0; i &amp;lt; total; i ++) {
            List&amp;lt;Integer&amp;gt; cur = new ArrayList();
            for(int j = 0; j &amp;lt; nums.length; j ++) {
                if(((1 &amp;lt;&amp;lt; j) &amp;amp; i) != 0)
                    cur.add(nums[j]);
            }
            result.add(cur);
        }
        return result;
    }

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Counting Bits</title>
      <link>http://yjn93.github.io/dev/Counting-Bits/</link>
      <pubDate>Sat, 12 Nov 2016 15:10:24 -0500</pubDate>
      
      <guid>http://yjn93.github.io/dev/Counting-Bits/</guid>
      <description>

&lt;h1 id=&#34;problem-description:022354bb3fdd3cdde4f44cb9f57b56b0&#34;&gt;Problem description&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/counting-bits/&#34;&gt;LeetCode 338&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1&amp;rsquo;s in their binary representation and return them as an array.&lt;/p&gt;

&lt;h2 id=&#34;example:022354bb3fdd3cdde4f44cb9f57b56b0&#34;&gt;Example:&lt;/h2&gt;

&lt;p&gt;For num = 5 you should return [0,1,1,2,1,2]&lt;/p&gt;

&lt;h2 id=&#34;my-dp-solution:022354bb3fdd3cdde4f44cb9f57b56b0&#34;&gt;My DP Solution&lt;/h2&gt;

&lt;p&gt;This problem can be solved by dynamic programming because the count of bits follow certains rules as the number grows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;		0	0
		1	1
		2	10
		3	11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The number 2 is adding another bit 1 in front of number 0; the number 3 is adding another bit 1 at the beginning of number 1. So my solution is to track the previous size of numbers that can be represented by a fix number of bits. For example, we have 0, 1 initially, the size is 2. Then for 3, 4, we apply the formula:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dp[i] = dp[i-size] + 1
dp[2] = dp[2 - 2] + 1 = dp[0] + 1 
dp[3] = dp[3 - 2] + 1 = dp[1] + 1

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, for number 4, we need more bits to represent it, so the previous size is updated to 4, and dp[4], dp[5], dp[6], dp[7] can be calculated by dp[0], dp[1], dp[2], dp[3]. My code is as following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int[] countBits(int num) {
        if(num == 0) return new int[]{0};
        int[] dp = new int[num+1];
        dp[0] = 0;
        dp[1] = 1;
        int size = 2;
        for(int i = 2; i &amp;lt;= num; i ++) {
            if(i - size == size)
                size = i;
            dp[i] = 1 + dp[i-size];
        }
        return dp;
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;another-dp-solution-combining-bit-manipulation:022354bb3fdd3cdde4f44cb9f57b56b0&#34;&gt;Another DP solution combining Bit Manipulation&lt;/h2&gt;

&lt;p&gt;Instead of adding the bit 1 infront of the previous cycle, this brilliant solution think it as deleting the last bit to obtain the number of bits without last bit, then add another counting for last bit if the last bit is 1.&lt;/p&gt;

&lt;p&gt;4-line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int[] countBits(int num) {
        int[] dp = new int[num+1];
        for(int i = 1; i &amp;lt;= num; i ++) 
            dp[i] = dp[i&amp;gt;&amp;gt;1] + (i&amp;amp;1);
        return dp;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice the priority for &amp;amp; operator is lower than +, so we need to use () for (i&amp;amp;1).&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>