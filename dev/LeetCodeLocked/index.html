	<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.15" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title> LeetCodeLocked &middot; 木秀于南 </title>

  
  <link rel="stylesheet" href="http://yjn93.github.io/css/poole.css">
  <link rel="stylesheet" href="http://yjn93.github.io/css/syntax.css">
  <link rel="stylesheet" href="http://yjn93.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="木秀于南" />
</head>

	<body class="">
		<div class="sidebar">
    <div class="sidebar-about">
      <a href="http://yjn93.github.io/"><h1>木秀于南</h1></a>
      <p class="lead">
	   Jianan Yue  
      </p>
    </div>

	        <ul class ="sidebar-nav">
             <li>
                <a href="/">Home</a>
            </li>
            <li>
                <a href="/blog/">Blog</a>
            </li>
            <li>
            	<a href="/dev/">Dev</a>
            </li>
            <li>
            	<a href="/gallery/">Gallery</a>
            </li>
            <li>
				<a href="/about">About</a>
            </li>
        </ul>


	<p class = "copyright">
		powered by <a href = "http://gohugo.io">Hugo</a>
		<br>© 2016 Jianan Yue. All right reserved.
	</p>
</div>


		<div class="content container">
			<div class="post">
			 	<h1>LeetCodeLocked</h1>
			  <span class="post-date">Thu, Jan 5, 2017</span>
			      

<h1 id="range-addition:391bf8c2ccd1748d42853cd47f55ff11">Range Addition</h1>

<p>Assume you have an array of length n initialized with all 0&rsquo;s and are given k update operations.</p>

<p>Each operation is represented as a triplet: [startIndex, endIndex, inc] which increments each element of subarray A[startIndex &hellip; endIndex] /(startIndex and endIndex inclusive) with inc.</p>

<p>Return the modified array after all k operations were executed.</p>

<h2 id="example:391bf8c2ccd1748d42853cd47f55ff11">Example</h2>

<pre><code>Given:

    length = 5,
    updates = [
        [1,  3,  2],
        [2,  4,  3],
        [0,  2, -2]
    ]

Output:

    [-2, 0, 3, 5, 3]
</code></pre>

<h2 id="explanation:391bf8c2ccd1748d42853cd47f55ff11">Explanation</h2>

<pre><code>Initial state:
[ 0, 0, 0, 0, 0 ]

After applying operation [1, 3, 2]:
[ 0, 2, 2, 2, 0 ]

After applying operation [2, 4, 3]:
[ 0, 2, 5, 5, 3 ]

After applying operation [0, 2, -2]:
[-2, 0, 3, 5, 3 ]
</code></pre>

<h2 id="solution:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<p>Only update the start and end+1 index every time is sufficient.</p>

<pre><code>    public int[] getModifiedArray(int length, int[][] updates) {
        int[] result = new int[length];
        for(int[] update: updates) {
            result[update[0]] += update[2];
            if(update[1] &lt; length-1)
                result[update[1]+1] -= update[2];
        }
        
        for(int i = 1; i &lt; length; i ++)
            result[i] += result[i-1];
        return result;
    }
</code></pre>

<h1 id="shortest-word-distance:391bf8c2ccd1748d42853cd47f55ff11">Shortest Word Distance</h1>

<p>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p>

<p>For example,</p>

<p>Assume that words = [&ldquo;practice&rdquo;, &ldquo;makes&rdquo;, &ldquo;perfect&rdquo;, &ldquo;coding&rdquo;, &ldquo;makes&rdquo;].</p>

<p>Given word1 = “coding”, word2 = “practice”, return 3.</p>

<p>Given word1 = &ldquo;makes&rdquo;, word2 = &ldquo;coding&rdquo;, return 1.</p>

<h2 id="solution-1:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<pre><code>    public int shortestDistance(String[] words, String word1, String word2) {
        int p1 = -1, p2 = -1;
        int min = words.length;
        for(int i = 0; i &lt; words.length; i ++) {
            if(words[i].equals(word1))
                p1 = i;
            if(words[i].equals(word2))
                p2 = i;
            if(p1 != -1 &amp;&amp; p2 != -1)
                min = Math.min(Math.abs(p2 - p1), min);
        }
        return min;
    }
</code></pre>

<h2 id="follow-up-1:391bf8c2ccd1748d42853cd47f55ff11">Follow up 1</h2>

<p>Now you are given the list of words and your method will be called repeatedly many times with different parameters. How would you optimize it?</p>

<p>Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list.</p>

<h3 id="solution-2:391bf8c2ccd1748d42853cd47f55ff11">Solution</h3>

<p>Use HashMap</p>

<pre><code>public class WordDistance {
    HashMap&lt;String, List&lt;Integer&gt;&gt; map;
    
    public WordDistance(String[] words) {
        map = new HashMap();
        for(int i = 0; i &lt; words.length; i ++) {
            if(!map.containsKey(words[i]))
                map.put(words[i], new ArrayList());
            map.get(words[i]).add(i);
        }
    }

    public int shortest(String word1, String word2) {
        int min = Integer.MAX_VALUE;
        for(int i: map.get(word1)) {
            for(int j: map.get(word2)) 
                min = Math.min(Math.abs(i - j), min);
        }
        return min;
    }
}
</code></pre>

<h2 id="follow-up-2:391bf8c2ccd1748d42853cd47f55ff11">Follow up 2</h2>

<p>Now word1 could be the same as word2 and they represent two individual words in the list.</p>

<h3 id="solution-3:391bf8c2ccd1748d42853cd47f55ff11">Solution</h3>

<p>If we remove the boolean same variable, it can solve the basic problem.</p>

<pre><code>    public int shortestWordDistance(String[] words, String word1, String word2) {
        int index = -1;
        int min = words.length;
        boolean same = word1.equals(word2);
        for(int i = 0; i &lt; words.length; i ++) {
            if(words[i].equals(word1) || words[i].equals(word2)) {
                if(index != -1 &amp;&amp; (same || !words[index].equals(words[i]))){
                    min = Math.min(i - index, min);
                }
                index = i;
            }
        }
        return min;
    }

</code></pre>

<h1 id="zigzag-iterator:391bf8c2ccd1748d42853cd47f55ff11">Zigzag iterator</h1>

<p>Given two 1d vectors, implement an iterator to return their elements alternately.</p>

<p>For example, given two 1d vectors:</p>

<pre><code>v1 = [1, 2]
v2 = [3, 4, 5, 6]
By calling next repeatedly until hasNext returns false, the order of elements returned by next should be:
[1, 3, 2, 4, 5, 6]
</code></pre>

<p>Follow up: What if you are given k 1d vectors? How well can your code be extended to such cases?</p>

<pre><code>[1,2,3]
[4,5,6,7]
[8,9]
It should return [1,4,8,2,5,9,3,6,7].
</code></pre>

<h2 id="solution-4:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<p>Uses a linkedlist to store the iterators in different vectors. Every time we call next(), we pop an element from the list, and re-add it to the end to cycle through the lists.</p>

<pre><code>
public class ZigzagIterator {
    LinkedList&lt;Iterator&gt; list;
    
    public ZigzagIterator(List&lt;Integer&gt; v1, List&lt;Integer&gt; v2) {
        list = new LinkedList();
        if(!v1.isEmpty())
            list.add(v1.iterator());
        if(!v2.isEmpty())
            list.add(v2.iterator());
    }

    public int next() {
        Iterator cur = list.remove();
        int result = (int)cur.next();
        if(cur.hasNext()) list.add(cur);
        return result;
    }

    public boolean hasNext() {
        return !list.isEmpty();
    }
}

</code></pre>

<p>Many things need to be notice in code:</p>

<ul>
<li><p>For the member list, we need to specify its type as LinkedList, or Queue. If we use List<Iterator> list, we cannot use remove() or poll() method because they are not specified by interface List, but by Queue or Deque.</p></li>

<li><p>After we got the Iterator cur, we need to convert cur.next() to (int), otherwise it will raise Object cannot convert to int exception.</p></li>
</ul>

<h1 id="flip-game:391bf8c2ccd1748d42853cd47f55ff11">Flip Game</h1>

<p>You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two consecutive &ldquo;++&rdquo; into &ldquo;&ndash;&rdquo;. The game ends when a person can no longer make a move and therefore the other person will be the winner.</p>

<p>Write a function to determine if the starting player can guarantee a win.</p>

<p>For example, given s = &ldquo;++++&rdquo;, return true. The starting player can guarantee a win by flipping the middle &ldquo;++&rdquo; to become &ldquo;+&ndash;+&rdquo;.</p>

<h2 id="solution-5:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<pre><code>    Map&lt;String, Boolean&gt; winMap = new HashMap();
    
    public boolean canWin(String s) {
        if(winMap.containsKey(s)) return winMap.get(s);
        for(int i = -1; (i = s.indexOf(&quot;++&quot;, i + 1)) &gt;= 0; ) {
            String t = s.substring(0, i) + &quot;--&quot; + s.substring(i+2);
            if(!canWin(t)) {
                winMap.put(s, true);
                return true;
            }
        }
        winMap.put(s, false);
        return false;
    }

</code></pre>

<h1 id="generalized-abbreviation:391bf8c2ccd1748d42853cd47f55ff11">Generalized Abbreviation</h1>

<p>Write a function to generate the generalized abbreviations of a word.</p>

<h2 id="example-1:391bf8c2ccd1748d42853cd47f55ff11">Example</h2>

<p>Given word = &ldquo;word&rdquo;, return the following list (order does not matter):</p>

<pre><code>[&quot;word&quot;, &quot;1ord&quot;, &quot;w1rd&quot;, &quot;wo1d&quot;, &quot;wor1&quot;, &quot;2rd&quot;, &quot;w2d&quot;, &quot;wo2&quot;, &quot;1o1d&quot;, &quot;1or1&quot;, &quot;w1r1&quot;, &quot;1o2&quot;, &quot;2r1&quot;, &quot;3d&quot;, &quot;w3&quot;, &quot;4&quot;]

</code></pre>

<h2 id="solution-6:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<p>For each character, we can choose to put or not put it in the abbreviation. So we can use backtracking</p>

<pre><code>
    public List&lt;String&gt; generateAbbreviations(String word) {
        List&lt;String&gt; result = new ArrayList();
        dfs(result, new StringBuilder(), word, 0, 0);
        return result;
    }
    
    public void dfs(List&lt;String&gt; result, StringBuilder sb, String word, int pos, int count) {
        int len = sb.length();
        if(pos == word.length()) {
            if(count &gt; 0) sb.append(count);
            result.add(sb.toString());
        } else {
            dfs(result, sb, word, pos+1, count+1);
            if(count &gt; 0)
                sb.append(count);
            dfs(result, sb.append(word.charAt(pos)), word, pos+1, 0);
        }
        sb.setLength(len);
    }

</code></pre>

<h1 id="maximum-size-subarray-sum-equals-k:391bf8c2ccd1748d42853cd47f55ff11">Maximum Size Subarray Sum Equals k</h1>

<p>Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn&rsquo;t one, return 0 instead.</p>

<pre><code>
Example 1:
Given nums = [1, -1, 5, -2, 3], k = 3,
return 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longest)

Example 2:
Given nums = [-2, -1, 2, 1], k = 1,
return 2. (because the subarray [-1, 2] sums to 1 and is the longest

</code></pre>

<h2 id="solution-7:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<p>I didn&rsquo;t come up with the idea of using map.</p>

<pre><code>    public int maxSubArrayLen(int[] nums, int k) {
        int max = 0, sum = 0;
        HashMap&lt;Integer, Integer&gt; map = new HashMap();
        for(int i = 0; i &lt; nums.length; i ++) {
            sum += nums[i];
            if(sum == k) 
                max = i + 1;
            else if(map.containsKey(sum - k))
                max = Math.max(max, i - map.get(sum - k));
            if(!map.containsKey(sum))
                map.put(sum, i);
        }
        return max;
    }

</code></pre>

<h1 id="factor-combinations:391bf8c2ccd1748d42853cd47f55ff11">Factor Combinations</h1>

<p>Numbers can be regarded as product of its factors. Write a function that takes an integer n and return all possible combinations of its factors,</p>

<h2 id="example-2:391bf8c2ccd1748d42853cd47f55ff11">Example</h2>

<pre><code>input: 1
output: []

input: 37
output: []

input: 12
output:
[
  [2, 6],
  [2, 2, 3],
  [3, 4]
]

input: 32
output:
[
  [2, 16],
  [2, 2, 8],
  [2, 2, 2, 4],
  [2, 2, 2, 2, 2],
  [2, 4, 4],
  [4, 8]
]

</code></pre>

<h2 id="solution-8:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<p>Backtracking, similar to combination sum.</p>

<pre><code>    public List&lt;List&lt;Integer&gt;&gt; getFactors(int n) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList();
        helper(result, new ArrayList(), n, 2);
        return result;
    }
    
    public void helper(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; cur, int n, int start) {
        for(int i = start; i &lt;= n / i; i ++) {
            if(n % i == 0) {
                cur.add(i);
                cur.add(n/i);
                result.add(new ArrayList(cur));
                cur.remove(cur.size()-1);
                helper(result, cur, n/i, i);
                cur.remove(cur.size()-1);
            }
        }
    }

</code></pre>

<h1 id="bomb-enemy:391bf8c2ccd1748d42853cd47f55ff11">Bomb Enemy</h1>

<p>Given a 2D grid, each cell is either a wall &lsquo;W&rsquo;, an enemy &lsquo;E&rsquo; or empty &lsquo;0&rsquo; (the number zero), return the maximum enemies you can kill using one bomb.</p>

<p>The bomb kills all the enemies in the same row and column from the planted point until it hits the wall since the wall is too strong to be destroyed.</p>

<p>Note that you can only put the bomb at an empty cell.</p>

<h2 id="example-3:391bf8c2ccd1748d42853cd47f55ff11">Example</h2>

<pre><code>For the given grid

0 E 0 0
E 0 W E
0 E 0 0

return 3. (Placing a bomb at (1,1) kills 3 enemies)
</code></pre>

<h2 id="solution-9:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<p>Using dp, only need to record number of enemies in current row and every column. If encounter a wall, update the values.</p>

<pre><code>    public int maxKilledEnemies(char[][] grid) {
        if(grid == null || grid.length == 0 || grid[0].length == 0)
            return 0;
        int m = grid.length, n = grid[0].length;
        int row = 0;
        int[] col = new int[n];
        int max = 0;
        for(int i = 0; i &lt; m; i ++) {
            for(int j = 0; j &lt; n; j ++) {
                if(grid[i][j] == 'W') continue;
                if(j == 0 || grid[i][j-1] == 'W') {
                    row = 0;
                    for(int k = j; k &lt; n &amp;&amp; grid[i][k] != 'W'; k ++)
                        row += grid[i][k] == 'E' ? 1 : 0;
                }
                if(i == 0 || grid[i-1][j] == 'W') {
                    col[j] = 0;
                    for(int k = i; k &lt; m &amp;&amp; grid[k][j] != 'W'; k ++)
                        col[j] += grid[k][j] == 'E' ? 1 : 0;
                }
                if(grid[i][j] == '0')
                    max = Math.max(row + col[j], max);
            }
        }
        return max;
    }

</code></pre>

<h1 id="inorder-successor-in-bst:391bf8c2ccd1748d42853cd47f55ff11">Inorder Successor in BST</h1>

<p>Given a binary search tree and a node in it, find the in-order successor of that node in the BST.</p>

<p>Note: If the given node has no in-order successor in the tree, return null.</p>

<h2 id="solution-10:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<pre><code>	//Iterative
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        TreeNode cur = root;
        TreeNode result = null;
        while(cur != null) {
            if(cur.val &gt; p.val) {
                result = cur;
                cur = cur.left;
            } else {
                cur = cur.right;
            }
        }
        return result;
    }

	// Recursive
	public TreeNode successor(TreeNode root, TreeNode p) {
  		if (root == null)
    	return null;

  		if (root.val &lt;= p.val) {
    		return successor(root.right, p);
  		} else {
    		TreeNode left = successor(root.left, p);
    		return (left != null) ? left : root;
  		}
	}	
</code></pre>

<h1 id="find-the-celebrity:391bf8c2ccd1748d42853cd47f55ff11">Find the Celebrity</h1>

<p>Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.</p>

<p>Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: &ldquo;Hi, A. Do you know B?&rdquo; to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).</p>

<p>You are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n), your function should minimize the number of calls to knows.</p>

<p>Note: There will be exactly one celebrity if he/she is in the party. Return the celebrity&rsquo;s label if there is a celebrity in the party. If there is no celebrity, return -1.</p>

<h2 id="solution-11:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<pre><code>    public int findCelebrity(int n) {
        if(n &lt;= 1) return n-1;
        int cur = 0;
        for(int i = 1; i &lt; n; i ++) {
            if(knows(cur, i)) {
                    cur = i;
            }
        }
        for(int i = 0; i &lt; n; i ++) {
            if(i != cur &amp;&amp; (knows(cur, i) || !knows(i, cur)))
                return -1;
        }
        return cur;
    }

</code></pre>

			</div>

			
		</div>

  </body>
</html>
