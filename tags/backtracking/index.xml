<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Backtracking on 木秀于南</title>
    <link>http://yjn93.github.io/tags/backtracking/</link>
    <description>Recent content in Backtracking on 木秀于南</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© 2016 Jianan Yue. All right reserved.</copyright>
    <lastBuildDate>Sat, 26 Nov 2016 10:30:22 -0500</lastBuildDate>
    <atom:link href="http://yjn93.github.io/tags/backtracking/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Combination Sum</title>
      <link>http://yjn93.github.io/dev/Combination_Sum/</link>
      <pubDate>Sat, 26 Nov 2016 10:30:22 -0500</pubDate>
      
      <guid>http://yjn93.github.io/dev/Combination_Sum/</guid>
      <description>

&lt;h1 id=&#34;combination-sum-3:7a055b9f53e64947361af5747bddcbb5&#34;&gt;Combination Sum 3&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/combination-sum-iii/&#34;&gt;LeetCode 216&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.&lt;/p&gt;

&lt;h2 id=&#34;example:7a055b9f53e64947361af5747bddcbb5&#34;&gt;Example&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;k = 3, n = 7
[[1,2,4]]

k = 3, n = 9
[[1,2,6], [1,3,5], [2,3,4]]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution:7a055b9f53e64947361af5747bddcbb5&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;BackTracking&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum3(int k, int n) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
        helper(result, new ArrayList&amp;lt;Integer&amp;gt;(), k, n, 1);
        return result;
    }
    
    public void helper(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result, List&amp;lt;Integer&amp;gt; cur, int k, int n, int start) {
        if(k == 0 &amp;amp;&amp;amp; n == 0) {
            result.add(new ArrayList(cur));
            return;
        }
        if(k == 0 || start &amp;gt; n) return;
        for(int i = start; i &amp;lt;= 9 &amp;amp;&amp;amp; i &amp;lt;= n ; i ++) {
            cur.add(i);
            helper(result, cur, k-1, n-i, i+1);
            cur.remove(cur.size()-1);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;combination-sum-4:7a055b9f53e64947361af5747bddcbb5&#34;&gt;Combination Sum 4&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/combination-sum-iv/&#34;&gt;LeetCode 377&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.&lt;/p&gt;

&lt;h2 id=&#34;example-1:7a055b9f53e64947361af5747bddcbb5&#34;&gt;Example:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;nums = [1, 2, 3]
target = 4

The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

Note that different sequences are counted as different combinations.

Therefore the output is 7.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-1:7a055b9f53e64947361af5747bddcbb5&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;I used recursive solution first, but raised Time Limit Exceeded. This problem actually can be solve in DP because we only need to calculate the possible combinations for a subTarget once.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target+1];
        dp[0] = 1;
        for(int i = 1; i &amp;lt;= target; i ++) {
            for(int j = 0; j &amp;lt; nums.length; j ++) {
                if(i - nums[j] &amp;gt;= 0)
                    dp[i] += dp[i-nums[j]];
            }
        }
        return dp[target];
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>