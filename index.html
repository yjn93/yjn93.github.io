<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.15" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title> 木秀于南 &middot; 木秀于南 </title>

  
  <link rel="stylesheet" href="http://yjn93.github.io/css/poole.css">
  <link rel="stylesheet" href="http://yjn93.github.io/css/syntax.css">
  <link rel="stylesheet" href="http://yjn93.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="http://yjn93.github.io/index.xml" rel="alternate" type="application/rss+xml" title="木秀于南" />
</head>

<body class=" ">

<div class="sidebar">
    <div class="sidebar-about">
      <a href="http://yjn93.github.io/"><h1>木秀于南</h1></a>
      <p class="lead">
	   Jianan Yue  
      </p>
    </div>

	        <ul class ="sidebar-nav">
             <li>
                <a href="/">Home</a>
            </li>
            <li>
                <a href="/blog/">Blog</a>
            </li>
            <li>
            	<a href="/dev/">Dev</a>
            </li>
            <li>
            	<a href="/gallery/">Gallery</a>
            </li>
            <li>
				<a href="/about">About</a>
            </li>
        </ul>


	<p class = "copyright">
		powered by <a href = "http://gohugo.io">Hugo</a>
		<br>© 2016 Jianan Yue. All right reserved.
	</p>
</div>


    <div class="content container">
<div class="posts">

      
  <div class="post">
    <h1 class="post-title">
      <a href="http://yjn93.github.io/dev/BIT/">
        Binary Indexed Trees
      </a>
    </h1>

    <span class="post-date">Fri, Jan 20, 2017</span>

    

<h1 id="bit:32b8e87fcf011b19f769e4a32f7c0999">BIT</h1>

<p>Binary Indexed Trees is often used for storing frequencies and manipulating cumulative frequency tables.</p>

<ul>
<li><a href="https://www.topcoder.com/community/data-science/data-science-tutorials/binary-indexed-trees/">TopCoder explanation</a></li>
</ul>

<h2 id="init-tree:32b8e87fcf011b19f769e4a32f7c0999">Init tree</h2>

<pre><code>    void init(int[] nums) {
        maxIdx = nums.length;
        //The index of BIT starts from 1
        BIT = new int[maxIdx + 1];
        for(int i = 0; i &lt; maxIdx; i ++)
            updateBIT(i+1, nums[i]);
    }

</code></pre>

<h2 id="read:32b8e87fcf011b19f769e4a32f7c0999">Read</h2>

<pre><code>    int readBIT(int idx) {
        int sum = 0;
        while(idx &gt; 0) {
            sum += BIT[idx];
            idx -= (idx &amp; -idx);
        }
        return sum;
    }
</code></pre>

<h2 id="update:32b8e87fcf011b19f769e4a32f7c0999">Update</h2>

<pre><code>    void updateBIT(int idx, int diff) {
        while(idx &lt;= maxIdx) {
            BIT[idx] += diff;
            idx += (idx &amp; -idx);
        } 
    }
</code></pre>

<h1 id="range-sum-query-mutable:32b8e87fcf011b19f769e4a32f7c0999">Range Sum Query - Mutable</h1>

<p>Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.</p>

<p>The update(i, val) function modifies nums by updating the element at index i to val.</p>

<h2 id="example:32b8e87fcf011b19f769e4a32f7c0999">Example</h2>

<pre><code>Given nums = [1, 3, 5]

sumRange(0, 2) -&gt; 9
update(1, 2)
sumRange(0, 2) -&gt; 8

</code></pre>

<h2 id="solution-segment-tree:32b8e87fcf011b19f769e4a32f7c0999">Solution - Segment Tree</h2>

<p>Segement Tree is like a complete binary tree. Each node represent sum of some range (from a start index to an end index). The children of one node has a subrange of the range.</p>

<pre><code>    segmentNode root;
    int[] nums;

    public NumArray(int[] nums) {
        this.nums = nums;
        if(nums.length != 0)
        root = buildTree(nums, 0, nums.length-1);
    }

    segmentNode buildTree(int[] nums, int start, int end) {
        segmentNode root = new segmentNode(start, end);
        if(start == end)
            root.sum = nums[start];
        else {
            int mid = (end-start)/2 + start;
            root.left = buildTree(nums, start, mid);
            root.right = buildTree(nums, mid+1, end);
            root.sum = root.left.sum + root.right.sum;
        }
        return root;
    }
    
    void update(int i, int val) {
        int diff = nums[i] - val;
        nums[i] = val;
        updateNode(root, i, diff);
    }
    
    void updateNode(segmentNode root, int i, int diff) {
        if(root == null || root.start &gt; i || root.end &lt; i) return;
        root.sum -= diff;
        updateNode(root.left, i, diff);
        updateNode(root.right, i, diff);
    }

    public int sumRange(int i, int j) {
        return sumRange(root, i, j);
    }
    
    int sumRange(segmentNode root, int i, int j) {
        if(root == null || root.start &gt; j || root.end &lt; i) return 0;
        if(root.start &gt;= i &amp;&amp; root.end &lt;= j) return root.sum;
        return sumRange(root.left, i, j) + sumRange(root.right, i, j);
    }
    
}

class segmentNode {
    int start;
    int end;
    int sum;
    segmentNode left;
    segmentNode right;
    
    segmentNode(int start, int end) {
        this.start = start;
        this.end = end;
        this.sum = 0;
        left = null;
        right = null;
    }
}

</code></pre>

<h2 id="solution-bit:32b8e87fcf011b19f769e4a32f7c0999">Solution - BIT</h2>

<pre><code>    int[] nums;
    int[] BIT;
    int maxIdx;

    public NumArray(int[] nums) {
        this.nums = nums;
        init(nums);
    }

    void init(int[] nums) {
        maxIdx = nums.length;
        //The index of BIT starts from 1
        BIT = new int[maxIdx + 1];
        for(int i = 0; i &lt; maxIdx; i ++)
            updateBIT(i+1, nums[i]);
    }
    
    void updateBIT(int idx, int diff) {
        while(idx &lt;= maxIdx) {
            BIT[idx] += diff;
            idx += (idx &amp; -idx);
        } 
    }
    
    void update(int i, int val) {
        int diff = val - nums[i];
        nums[i] = val;
        updateBIT(i+1, diff);
    }
    
    int readBIT(int idx) {
        int sum = 0;
        while(idx &gt; 0) {
            sum += BIT[idx];
            idx -= (idx &amp; -idx);
        }
        return sum;
    }
    
    public int sumRange(int i, int j) {
        return readBIT(j+1) - readBIT(i);
    }

</code></pre>

<h1 id="range-sum-query-2d-mutable:32b8e87fcf011b19f769e4a32f7c0999">Range Sum Query 2D - Mutable</h1>

<p>Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).</p>

<h2 id="example-1:32b8e87fcf011b19f769e4a32f7c0999">Example</h2>

<pre><code>Given matrix = [
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]

sumRegion(2, 1, 4, 3) -&gt; 8
update(3, 2, 2)
sumRegion(2, 1, 4, 3) -&gt; 10

</code></pre>

<h2 id="solution:32b8e87fcf011b19f769e4a32f7c0999">Solution</h2>

<pre><code>    int[][] BIT;
    int[][] nums;
    int m;
    int n;

    public NumMatrix(int[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return;
        m = matrix.length;
        n = matrix[0].length;
        nums = matrix;
        BIT = new int[m+1][n+1];
        for(int i = 0; i &lt; m; i ++) {
            for(int j = 0; j &lt; n; j ++) {
                updateBIT(i+1, j+1, matrix[i][j]);
            }
        }
    }

    public void update(int row, int col, int val) {
        int diff = val - nums[row][col];
        nums[row][col] = val;
        updateBIT(row+1, col+1, diff);
    }
    
    public void updateBIT(int x, int y, int diff) {
        for(int i = x; i &lt;= m; i += (i &amp; -i))  {
            for(int j = y; j &lt;= n; j += (j &amp; -j)) {
                BIT[i][j] += diff;
            }
        }
    }
    
    public int readBIT(int x, int y) {
        int sum = 0;
        for(int i = x; i &gt; 0; i -=(i &amp; -i)) {
            for(int j = y; j &gt; 0; j -= (j &amp; -j)) {
                sum += BIT[i][j];
            }
        }
        return sum;
    }

    public int sumRegion(int row1, int col1, int row2, int col2) {
        return readBIT(row2+1, col2+1) - readBIT(row2+1, col1) - readBIT(row1, col2+1) + readBIT(row1, col1);
    }

</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://yjn93.github.io/dev/KMP/">
        KMP-String Pattern Match
      </a>
    </h1>

    <span class="post-date">Fri, Jan 13, 2017</span>

    

<h1 id="kmp:cdddce7445004a283bb5a182f0d88bd4">KMP</h1>

<p>KMP is a string searching algorithm searches for occurrences of a &ldquo;word&rdquo; W within a main &ldquo;text string&rdquo; S by employing the observation that when a mismatch occurs, the word itself embodies sufficient information to determine where the next match could begin, thus bypassing re-examination of previously matched characters.</p>

<ul>
<li><a href="http://blog.csdn.net/v_july_v/article/details/7041827">A link with detailed explanation</a></li>
</ul>

<h2 id="calculate-longest-prefix-suffix-lps-array:cdddce7445004a283bb5a182f0d88bd4">Calculate Longest Prefix Suffix (LPS) Array</h2>

<pre><code>    public int[] kmp(String str) {
        int len = str.length();
        int[] LPS = new int[len];
        LPS[0] = 0;
        int k = 0, j = 1;
        while(j &lt; len) {
            if(str.charAt(k) == str.charAt(j))
                LPS[j ++] = ++ k;
            else if(k == 0)
                LPS[j ++] = 0;
            else
                k = LPS[k-1];
        }
		return LPS;
    }

</code></pre>

<h2 id="calculate-next-array:cdddce7445004a283bb5a182f0d88bd4">Calculate Next Array</h2>

<pre><code>    public int[] kmp(String str) {
        int len = str.length();
        int[] next = new int[len];
        next[0] = -1;
        int k = -1, j = 0;
        while(j &lt; len-1) {
            if(k == -1 || str.charAt(k) == str.charAt(j))
                next[++ j] = ++ k;
            else 
                k = next[k];
        }
        return next;
    }

</code></pre>

<h2 id="optimised-next-array:cdddce7445004a283bb5a182f0d88bd4">Optimised Next Array</h2>

<pre><code>    public int[] kmp(String str) {
        int len = str.length();
        int[] next = new int[len];
        next[0] = -1;
        int k = -1, j = 0;
        while(j &lt; len-1) {
            if(k == -1 || str.charAt(k) == str.charAt(j)) {
                if(str.charAt(++ k) == str.charAt(++ j))
                    next[j] = next[k];  //make sure str(j) != str(next[j])
                else    
                    next[j] = k;
            }
            else 
                k = next[k];
        }
        return next;
    }

</code></pre>

<h1 id="encode-string-with-shortest-length:cdddce7445004a283bb5a182f0d88bd4">Encode String with Shortest Length</h1>

<ul>
<li><a href="https://leetcode.com/problems/encode-string-with-shortest-length/">LeetCode 471</a></li>
</ul>

<h2 id="solution:cdddce7445004a283bb5a182f0d88bd4">Solution</h2>

<p>dp[i][j] = string from index i to index j in encoded form.</p>

<p>We can write the following formula as:-
dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j]) or if we can find some pattern in string from i to j which will result in more less length.</p>

<p>Time Complexity = O(n^3)</p>

<pre><code>    public String encode(String s) {
        if(s == null || s.length() &lt; 5) return s;
        int len = s.length();
        String[][] dp = new String[len][len];
        
        for(int l = 0; l &lt; len; l ++) {
            for(int i = 0; i &lt; len-l; i ++) {
                int j = i + l;
                String str = s.substring(i, j + 1);
                dp[i][j] = str;
                if(l &lt; 4) continue;
                for(int k = i; k &lt; j; k ++) {
                    if(dp[i][k].length() + dp[k+1][j].length() &lt; dp[i][j].length())
                        dp[i][j] = dp[i][k] + dp[k+1][j];
                }
                String pattern = kmp(str);
                if(pattern.length() == str.length()) continue;  // no repeat pattern found
                String patternEncode = str.length()/pattern.length() + &quot;[&quot; + dp[i][i+pattern.length()-1] + &quot;]&quot;;
                if(patternEncode.length() &lt; dp[i][j].length())
                    dp[i][j] = patternEncode;
            }
        }
        System.out.println(dp[0][7]);
        return dp[0][len-1];
    }
    
    public String kmp(String str) {
        int len = str.length();
        int[] LPS = new int[len];
        LPS[0] = 0;
        int k = 0, j = 1;
        while(j &lt; len) {
            if(str.charAt(k) == str.charAt(j))
                LPS[j ++] = ++ k;
            else if(k == 0)
                LPS[j ++] = 0;
            else
                k = LPS[k-1];
        }
        String pattern = str.substring(LPS[len-1]);
        if(pattern.length() != len &amp;&amp; len % pattern.length() == 0)
            return pattern;
        return str;
    }

</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://yjn93.github.io/dev/LeetCodeHard/">
        LeetCodeHard
      </a>
    </h1>

    <span class="post-date">Fri, Jan 13, 2017</span>

    

<h1 id="best-meeting-point:76dac5b6b228718d148e25520d85376a">Best Meeting Point</h1>

<p>A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.</p>

<p>For example, given three people living at (0,0), (0,4), and (2,2)</p>

<pre><code>1 - 0 - 0 - 0 - 1
|   |   |   |   |
0 - 0 - 0 - 0 - 0
|   |   |   |   |
0 - 0 - 1 - 0 - 0

</code></pre>

<p>The point (0,2) is an ideal meeting point, as the total travel distance of 2+2+2=6 is minimal. So return 6.</p>

<h2 id="solution:76dac5b6b228718d148e25520d85376a">Solution</h2>

<p>Try to solve it in one dimension first. Similar to the problem <em>Minimum Moves to Equal Array Elements</em></p>

<pre><code>    public int minTotalDistance(int[][] grid) {
        if(grid == null || grid.length == 0 || grid[0].length == 0)
            return 0;
        int m = grid.length, n = grid[0].length;
        List&lt;Integer&gt; rows = new ArrayList();
        List&lt;Integer&gt; cols = new ArrayList();
        for(int i = 0; i &lt; m; i ++) {
            for(int j = 0; j &lt; n; j ++) {
                if(grid[i][j] == 1)
                    rows.add(i);
            }
        }
        for(int j = 0; j &lt; n; j ++) {
            for(int i = 0; i &lt; m; i ++) {
                if(grid[i][j] == 1)
                    cols.add(j);
            }
        }
        
        return getMin(rows) + getMin(cols);
    }
    
    public int getMin(List&lt;Integer&gt; list) {
        int left = 0, right = list.size() - 1;
        int sum = 0;
        while(left &lt; right)
            sum += list.get(right --) - list.get(left ++);
        return sum;
    }

</code></pre>

<h1 id="smallest-rectangle-enclosing-black-pixels:76dac5b6b228718d148e25520d85376a">Smallest Rectangle Enclosing Black Pixels</h1>

<p>An image is represented by a binary matrix with 0 as a white pixel and 1 as a black pixel. The black pixels are connected, i.e., there is only one black region. Pixels are connected horizontally and vertically. Given the location (x, y) of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels.</p>

<h2 id="example:76dac5b6b228718d148e25520d85376a">Example</h2>

<pre><code>[
  &quot;0010&quot;,
  &quot;0110&quot;,
  &quot;0100&quot;
]
and x = 0, y = 2,
Return 6.

</code></pre>

<h2 id="solution-1:76dac5b6b228718d148e25520d85376a">Solution</h2>

<p>I used dfs to find the boundary, but we don&rsquo;t need to search every black cell. All the black cells are connected, in a projected 1D array all the black pixels are also connected.</p>

<p>We can use binary search to search boundaries.</p>

<pre><code>    public int minArea(char[][] image, int x, int y) {
        if(image == null || image.length == 0 || image[0].length == 0)
            return 0;
        int y_min = searchCols(image, 0, y, true);
        int y_max = searchCols(image, y + 1, image[0].length, false);
        int x_min = searchRows(image, 0, x, true);
        int x_max = searchRows(image, x + 1, image.length, false);
        
        return (x_max - x_min) * (y_max - y_min);
    }
    
    public int searchCols(char[][] image, int left, int right, boolean leftPart) {
        int m = image.length;
        while(left &lt; right) {
            int mid = (right - left) /2 + left;
            int k = 0;
            while(k &lt; m &amp;&amp; image[k][mid] == '0') k ++;
            if((k &lt; m) == leftPart)
                right = mid;
            else
                left = mid + 1;
        }
        return left;
    }
    
    public int searchRows(char[][] image, int top, int bottom, boolean topPart) {
        int n = image[0].length;
        while(top &lt; bottom) {
            int mid = (bottom - top) /2 + top;
            int k = 0;
            while(k &lt; n &amp;&amp; image[mid][k] == '0') k ++;
            if((k &lt; n) == topPart)
                bottom = mid;
            else
                top = mid + 1;
        }
        return top;
    }

</code></pre>

<h1 id="valid-word-square-easy:76dac5b6b228718d148e25520d85376a">Valid Word Square (easy)</h1>

<p>Given a sequence of words, check whether it forms a valid word square.</p>

<p>A sequence of words forms a valid word square if the kth row and column read the exact same string, where 0 ≤ k &lt; max(numRows, numColumns).</p>

<p>Note:
1. The number of words given is at least 1 and does not exceed 500.
2. Word length will be at least 1 and does not exceed 500.
3. Each word contains only lowercase English alphabet a-z.</p>

<h2 id="example-1:76dac5b6b228718d148e25520d85376a">Example</h2>

<pre><code>Input:
[
  &quot;abcd&quot;,
  &quot;bnrt&quot;,
  &quot;crmy&quot;,
  &quot;dtye&quot;
]

Output:
true

Input:
[
  &quot;abcd&quot;,
  &quot;bnrt&quot;,
  &quot;crm&quot;,
  &quot;dt&quot;
]

Output:
true

Input:
[
  &quot;ball&quot;,
  &quot;area&quot;,
  &quot;read&quot;,
  &quot;lady&quot;
]

Output:
false

</code></pre>

<h2 id="solution-2:76dac5b6b228718d148e25520d85376a">Solution</h2>

<p>Simple compare every symmetric char.</p>

<p>I failed on this case: [&ldquo;ball&rdquo;,&ldquo;asee&rdquo;,&ldquo;let&rdquo;,&ldquo;lep&rdquo;]</p>

<pre><code>    public boolean validWordSquare(List&lt;String&gt; words) {
        if(words == null || words.size() == 0) return true;
        int len = words.size();
        for(int i = 0; i &lt; len; i ++) {
            if(words.get(i).length() &gt; len) return false;
            for(int j = 0; j &lt; words.get(i).length(); j ++) {
                if(words.get(j).length() &lt;= i || words.get(j).charAt(i) != words.get(i).charAt(j))
                    return false;
            }
        }
        return true;
    }

</code></pre>

<h1 id="word-squares:76dac5b6b228718d148e25520d85376a">Word Squares</h1>

<p>Given a set of words (without duplicates), find all word squares you can build from them.</p>

<h2 id="example-2:76dac5b6b228718d148e25520d85376a">Example</h2>

<pre><code>Input:
[&quot;area&quot;,&quot;lead&quot;,&quot;wall&quot;,&quot;lady&quot;,&quot;ball&quot;]

Output:
[
  [ &quot;wall&quot;,
    &quot;area&quot;,
    &quot;lead&quot;,
    &quot;lady&quot;
  ],
  [ &quot;ball&quot;,
    &quot;area&quot;,
    &quot;lead&quot;,
    &quot;lady&quot;
  ]
]

Input:
[&quot;abat&quot;,&quot;baba&quot;,&quot;atan&quot;,&quot;atal&quot;]

Output:
[
  [ &quot;baba&quot;,
    &quot;abat&quot;,
    &quot;baba&quot;,
    &quot;atan&quot;
  ],
  [ &quot;baba&quot;,
    &quot;abat&quot;,
    &quot;baba&quot;,
    &quot;atal&quot;
  ]
]

</code></pre>

<h2 id="solution-3:76dac5b6b228718d148e25520d85376a">Solution</h2>

<p>We know that the sequence contains 4 words because the length of each word is 4.</p>

<p>Every word can be the first word of the sequence, let&rsquo;s take &ldquo;wall&rdquo; for example.</p>

<p>Which word could be the second word? Must be a word start with &ldquo;a&rdquo; (therefore &ldquo;area&rdquo;), because it has to match the second letter of word &ldquo;wall&rdquo;.</p>

<p>Which word could be the third word? Must be a word start with &ldquo;le&rdquo; (therefore &ldquo;lead&rdquo;), because it has to match the third letter of word &ldquo;wall&rdquo; and the third letter of word &ldquo;area&rdquo;.</p>

<p>What about the last word? Must be a word start with &ldquo;lad&rdquo; (therefore &ldquo;lady&rdquo;). For the same reason above.</p>

<pre><code>    class TrieNode {
        List&lt;String&gt; startWith;
        TrieNode[] children;
        
        public TrieNode() {
            startWith = new ArrayList();
            children = new TrieNode[26];
        }
    }
    
    class Trie {
        TrieNode root;
        
        public Trie(String[] words) {
            root = new TrieNode();
            for(String word: words) {
                TrieNode cur = root;
                for(char ch: word.toCharArray()) {
                    int idx = ch - 'a';
                    if(cur.children[idx] == null)
                        cur.children[idx] = new TrieNode();
                    cur.children[idx].startWith.add(word);
                    cur = cur.children[idx];
                } 
            }
        }
        
        public List&lt;String&gt; findPrefix(String prefix) {
            List&lt;String&gt; result = new ArrayList();
            TrieNode cur = root;
            for(char ch: prefix.toCharArray()) {
                int idx = ch - 'a';
                if(cur.children[idx] == null)
                    return result;
                cur = cur.children[idx];
            }
            return cur.startWith;
        }
    }
    
    public List&lt;List&lt;String&gt;&gt; wordSquares(String[] words) {
        List&lt;List&lt;String&gt;&gt; result = new ArrayList();
        if(words == null || words.length == 0) return result;
        int len = words[0].length();
        Trie trie = new Trie(words);
        List&lt;String&gt; cur = new ArrayList();
        for(String word: words) {
            cur.add(word);
            dfs(result, cur, trie, len);
            cur.remove(cur.size()-1);
        }
        return result;
    }
    
    public void dfs(List&lt;List&lt;String&gt;&gt; result, List&lt;String&gt; cur, Trie trie, int len) {
        if(cur.size() == len) {
            result.add(new ArrayList(cur));
            return;
        }
        int index = cur.size();
        StringBuilder prefix = new StringBuilder();
        for(String w: cur)
            prefix.append(w.charAt(index));
        List&lt;String&gt; startWith = trie.findPrefix(prefix.toString());
        for(String s: startWith) {
            cur.add(s);
            dfs(result, cur, trie, len);
            cur.remove(cur.size()-1);
        }
    }
</code></pre>

<h1 id="longest-substring-with-at-most-two-distinct-characters:76dac5b6b228718d148e25520d85376a">Longest Substring with At Most Two Distinct Characters</h1>

<p>Given a string, find the length of the longest substring T that contains at most 2 distinct characters.</p>

<p>For example, Given s = “eceba”,</p>

<p>T is &ldquo;ece&rdquo; which its length is 3.</p>

<h2 id="solution-4:76dac5b6b228718d148e25520d85376a">Solution</h2>

<pre><code>    public int lengthOfLongestSubstringTwoDistinct(String s) {
        int start = 0, next = -1;
        int result = 0;
        for(int end = 1; end &lt; s.length(); end ++) {
            if(s.charAt(end) == s.charAt(end-1)) continue;
            if(next &gt; -1 &amp;&amp; s.charAt(end) != s.charAt(next-1))
            {
                result = Math.max(result, end - start);
                start = next;
            }
            next = end;
        }
        return result &gt; s.length() - start ? result : s.length() - start;
    }

</code></pre>

<h1 id="longest-substring-with-at-most-k-distinct-characters:76dac5b6b228718d148e25520d85376a">Longest Substring with At Most K Distinct Characters</h1>

<p>Given a string, find the length of the longest substring T that contains at most k distinct characters.</p>

<p>For example, Given s = “eceba” and k = 2,</p>

<p>T is &ldquo;ece&rdquo; which its length is 3.</p>

<h2 id="solution-using-hashmap:76dac5b6b228718d148e25520d85376a">Solution using HashMap</h2>

<pre><code>    public int lengthOfLongestSubstringKDistinct(String s, int k) {
        HashMap&lt;Character, Integer&gt; map = new HashMap();
        int start = 0;
        int result = 0;
        for(int end = 0; end &lt; s.length(); end ++) {
            map.put(s.charAt(end), end);
            if(map.size() &gt; k) {
                int leftMost = end;
                for(int value: map.values()) {
                    leftMost = Math.min(leftMost, value);
                }
                map.remove(s.charAt(leftMost));
                start = leftMost + 1;
            }
            result = Math.max(result, end - start + 1);
        }
        return result;
    }

</code></pre>

<h2 id="solution-using-sliding-window:76dac5b6b228718d148e25520d85376a">Solution using Sliding Window</h2>

<pre><code>    public int lengthOfLongestSubstringKDistinct(String s, int k) {
        int[] count = new int[256];
        int num = 0, start = 0, result = 0;
        for(int i = 0; i &lt; s.length(); i ++) {
            if(count[s.charAt(i)] ++ == 0) num ++;
            if(num &gt; k) {
                while(-- count[s.charAt(start++)] &gt; 0);
                num --;
            }
            result = Math.max(result, i - start + 1);
        }
        return result;
    }

</code></pre>

<h1 id="word-pattern:76dac5b6b228718d148e25520d85376a">Word Pattern</h1>

<p>Given a pattern and a string str, find if str follows the same pattern.</p>

<p>Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty substring in str.</p>

<h2 id="examples:76dac5b6b228718d148e25520d85376a">Examples:</h2>

<pre><code>pattern = &quot;abab&quot;, str = &quot;redblueredblue&quot; should return true.
pattern = &quot;aaaa&quot;, str = &quot;asdasdasdasd&quot; should return true.
pattern = &quot;aabb&quot;, str = &quot;xyzabcxzyabc&quot; should return false.
</code></pre>

<h2 id="solution-5:76dac5b6b228718d148e25520d85376a">Solution</h2>

<p>Backtracking</p>

<pre><code>    public boolean wordPatternMatch(String pattern, String str) {
        HashMap&lt;Character, String&gt; map = new HashMap();
        HashSet&lt;String&gt; used = new HashSet();
        return helper(map, used, pattern, 0, str, 0);
    }
    
    public boolean helper(HashMap&lt;Character, String&gt; map, HashSet&lt;String&gt; used, String pattern, int idx, String str, int pos) {
        if(pos == str.length() &amp;&amp; idx == pattern.length())
            return true;
        if(pos == str.length() || idx == pattern.length())
            return false;
        char ch = pattern.charAt(idx);
        if(map.containsKey(ch)) {
            String temp = map.get(ch);
            if(!str.startsWith(temp, pos))
                return false;
            return helper(map, used, pattern, idx+1, str, pos + temp.length());
        }
        for(int i = pos; i &lt; str.length(); i ++) {
            String s = str.substring(pos, i+1);
            if(used.contains(s)) continue;
            map.put(ch, s);
            used.add(s);
            if(helper(map, used, pattern, idx+1, str, i+1))
                return true;
            map.remove(ch);
            used.remove(s);
        }
        return false;
    }

</code></pre>

<h1 id="closest-binary-search-tree-value-ii:76dac5b6b228718d148e25520d85376a">Closest Binary Search Tree Value II</h1>

<p>Given a non-empty binary search tree and a target value, find k values in the BST that are closest to the target.</p>

<p>Note:
- Given target value is a floating point.
- You may assume k is always valid, that is: k ≤ total nodes.
- You are guaranteed to have only one unique set of k values in the BST that are closest to the target.
- Follow up: assume that the BST is balanced, could you solve it in less than O(n) runtime (where n = total nodes)?</p>

<h2 id="solution-6:76dac5b6b228718d148e25520d85376a">Solution</h2>

<ol>
<li>Consider implement these two helper functions:

<ul>
<li>getPredecessor(N), which returns the next smaller node to N.</li>
<li>getSuccessor(N), which returns the next larger node to N.</li>
</ul></li>
<li>Try to assume that each node has a parent pointer, it makes the problem much easier.</li>
<li>Without parent pointer we just need to keep track of the path from the root to the current node using a stack.</li>
<li>You would need two stacks to track the path in finding predecessor and successor node separately.</li>
</ol>

<pre><code>    public List&lt;Integer&gt; closestKValues(TreeNode root, double target, int k) {
        Stack&lt;TreeNode&gt; pred = new Stack();
        Stack&lt;TreeNode&gt; succ = new Stack();
        initialStack(root, target, pred, succ);
        
        List&lt;Integer&gt; result = new ArrayList();
        
        while((!pred.isEmpty() || !succ.isEmpty()) &amp;&amp; k -- &gt; 0) {
            if(pred.isEmpty())
                result.add(getSucc(succ));
            else if(succ.isEmpty())
                result.add(getPred(pred));
            else if(Math.abs(succ.peek().val-target) &lt; Math.abs(pred.peek().val-target))
                result.add(getSucc(succ));
            else
                result.add(getPred(pred));
        }
        return result;
    }
    
    public void initialStack(TreeNode root, double target, Stack&lt;TreeNode&gt; pred, Stack&lt;TreeNode&gt; succ) {
        TreeNode cur = root;
        while(cur != null) {
            if(cur.val &gt; target) {
                succ.push(cur);
                cur = cur.left;
            } else {
                pred.push(cur);
                cur = cur.right;
            }
        } 
    }
    
    public int getPred(Stack&lt;TreeNode&gt; pred) {
        TreeNode res = pred.pop();
        TreeNode cur = res.left;
        while(cur != null) {
            pred.push(cur);
            cur = cur.right;
        }
        return res.val;
    }
    
    public int getSucc(Stack&lt;TreeNode&gt; succ) {
        TreeNode res = succ.pop();
        TreeNode cur = res.right;
        while(cur != null) {
            succ.push(cur);
            cur = cur.left;
        }
        return res.val;
    } 

</code></pre>

<h1 id="shortest-distance-from-all-buildings:76dac5b6b228718d148e25520d85376a">Shortest Distance from All Buildings</h1>

<p>You want to build a house on an empty land which reaches all buildings in the shortest amount of distance. You can only move up, down, left and right. You are given a 2D grid of values 0, 1 or 2, where:</p>

<ul>
<li>Each 0 marks an empty land which you can pass by freely.</li>
<li>Each 1 marks a building which you cannot pass through.</li>
<li>Each 2 marks an obstacle which you cannot pass through.</li>
</ul>

<p>For example, given three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2):</p>

<pre><code>1 - 0 - 2 - 0 - 1
|   |   |   |   |
0 - 0 - 0 - 0 - 0
|   |   |   |   |
0 - 0 - 1 - 0 - 0
</code></pre>

<p>The point (1,2) is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal. So return 7.</p>

<p>There will be at least one building. If it is not possible to build such house according to the above rules, return -1.</p>

<h2 id="solution-7:76dac5b6b228718d148e25520d85376a">Solution</h2>

<p>Walk only onto the cells that were reachable from all previous buildings. From the first building I only walk onto cells where grid is 0, and make them -1. From the second building I only walk onto cells where grid is -1, and I make them -2. And so on.</p>

<p>Use a distance matrix to record the total distance from each cell to all the buildings.</p>

<pre><code>    int[] delta = {-1, 0, 1, 0, -1};
    int min = Integer.MAX_VALUE;
    
    public int shortestDistance(int[][] grid) {
        if(grid == null || grid.length == 0 || grid[0].length == 0)
            return 0;
        int m = grid.length, n = grid[0].length;
        int[][] dis = new int[m][n];
        int start = 0;
        for(int i = 0; i &lt; m; i ++) {
            for(int j = 0; j &lt; n; j ++) {
                if(grid[i][j] == 1) {
                    bfs(grid, dis, i, j, start --);
                }
            }
        }
        return min == Integer.MAX_VALUE ? -1 : min;
    }

    public void bfs(int[][] grid, int[][] dis, int row, int col, int start) {
        Queue&lt;int[]&gt; queue = new LinkedList();
        queue.offer(new int[]{row, col});
        int level = 0;
        min = Integer.MAX_VALUE;
        while(!queue.isEmpty()) {
            int size = queue.size();
            level ++;
            while(size -- &gt; 0) {
                int[] cur = queue.poll();
                for(int i = 1; i &lt; delta.length; i ++) {
                    int x = cur[0] + delta[i-1];
                    int y = cur[1] + delta[i];
                    if(x &lt; 0 || x == grid.length || y &lt; 0 || y == grid[0].length || grid[x][y] != start)
                        continue;
                    dis[x][y] += level;
                    grid[x][y] --;
                    queue.offer(new int[]{x, y});
                    min = Math.min(min, dis[x][y]);
                }
            }
        }
    }

</code></pre>

<h1 id="rearrange-string-k-distance-apart:76dac5b6b228718d148e25520d85376a">Rearrange String k Distance Apart</h1>

<p>Given a non-empty string str and an integer k, rearrange the string such that the same characters are at least distance k from each other.</p>

<p>All input strings are given in lowercase letters. If it is not possible to rearrange the string, return an empty string &ldquo;&rdquo;.</p>

<h2 id="example-3:76dac5b6b228718d148e25520d85376a">Example</h2>

<pre><code>str = &quot;aabbcc&quot;, k = 3

Result: &quot;abcabc&quot;

The same letters are at least distance 3 from each other.

str = &quot;aaabc&quot;, k = 3 

Answer: &quot;&quot;

It is not possible to rearrange the string.

str = &quot;aaadbbcc&quot;, k = 2

Answer: &quot;abacabcd&quot;

Another possible answer is: &quot;abcabcda&quot;

The same letters are at least distance 2 from each other.

</code></pre>

<h2 id="solution-8:76dac5b6b228718d148e25520d85376a">Solution</h2>

<p>Use a hashMap to record the count for every character. Use a max heap to sort characters according to frequency. Use a waitQueue to freeze characters which are currently in the k size window.</p>

<pre><code>    public String rearrangeString(String str, int k) {
        if(k &lt; 2 || str.length() &lt; 2) return str;
        HashMap&lt;Character, Integer&gt; map = new HashMap();
        StringBuilder sb = new StringBuilder();
        for(char ch: str.toCharArray()) {
            if(!map.containsKey(ch))
                map.put(ch, 0);
            map.put(ch, map.get(ch)+1);
        }
        
		// Both ways are correct to create a priorityqueue.
        // Queue&lt;Map.Entry&lt;Character, Integer&gt;&gt; maxHeap 
        //     = new PriorityQueue(new Comparator&lt;Map.Entry&lt;Character, Integer&gt;&gt;() {
        //         public int compare(Map.Entry&lt;Character, Integer&gt; e1, Map.Entry&lt;Character, Integer&gt; e2) {
        //             return e2.getValue() - e1.getValue();
        //         }
        //         });
        PriorityQueue&lt;Map.Entry&lt;Character, Integer&gt;&gt; maxHeap 
            = new PriorityQueue&lt;&gt;((a, b) -&gt; (b.getValue() - a.getValue()));
        
        maxHeap.addAll(map.entrySet());
        Queue&lt;Map.Entry&lt;Character, Integer&gt;&gt; waitQueue = new LinkedList&lt;&gt;();
        
        while(!maxHeap.isEmpty()) {
            Map.Entry&lt;Character, Integer&gt; cur = maxHeap.poll();
            sb.append(cur.getKey());
            cur.setValue(cur.getValue()-1);
            waitQueue.offer(cur);
            
            if(waitQueue.size() &lt; k) continue;
            
            Map.Entry&lt;Character, Integer&gt; front = waitQueue.poll();
            if(front.getValue() &gt; 0)
                maxHeap.offer(front);
        }
        
        return sb.length() == str.length() ? sb.toString() : &quot;&quot;;
    }

</code></pre>

<h1 id="alien-dictionary:76dac5b6b228718d148e25520d85376a">Alien Dictionary</h1>

<p>There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.</p>

<ol>
<li>You may assume all letters are in lowercase.</li>
<li>If the order is invalid, return an empty string.</li>
<li>There may be multiple valid order of letters, return any one of them is fine.</li>
</ol>

<h2 id="example-4:76dac5b6b228718d148e25520d85376a">Example</h2>

<pre><code>Given the following words in dictionary,
[
  &quot;wrt&quot;,
  &quot;wrf&quot;,
  &quot;er&quot;,
  &quot;ett&quot;,
  &quot;rftt&quot;
]
The correct order is: &quot;wertf&quot;.

</code></pre>

<h2 id="solution-9:76dac5b6b228718d148e25520d85376a">Solution</h2>

<pre><code>    public String alienOrder(String[] words) {
        Map&lt;Character, Set&lt;Character&gt;&gt; map = new HashMap();
        Map&lt;Character, Integer&gt; degree = new HashMap();
        for(String w: words) {
            for(char ch: w.toCharArray())
                degree.put(ch, 0);
        }
        
        for(int i = 1; i &lt; words.length; i ++) {
            String w1 = words[i-1];
            String w2 = words[i];
			//if dictionary is [&quot;wtfkj&quot;, &quot;wtf&quot;], should return &quot; &quot;
            if (w1.length() &gt; w2.length() &amp;&amp; w2.equals(w1.substring(0, w2.length()))) 
                return &quot;&quot;;
            int len = Math.min(w1.length(), w2.length());
            for(int j = 0; j &lt; len; j ++) {
                char c1 = w1.charAt(j);
                char c2 = w2.charAt(j);
                if(c1 != c2) {
                    if(!map.containsKey(c1))
                        map.put(c1, new HashSet());
                    if(map.get(c1).add(c2)) {
                        degree.put(c2, degree.get(c2) + 1);
                    }
                    break;
                }
            }
        }
        
        Queue&lt;Character&gt; queue = new LinkedList();
        for(Map.Entry&lt;Character, Integer&gt; entry: degree.entrySet()) {
            if(entry.getValue() == 0) queue.offer(entry.getKey());
        }
        StringBuilder res = new StringBuilder();
        
        while(!queue.isEmpty()) {
            char cur = queue.poll();
            res.append(cur);
            if(map.containsKey(cur)){
                for(char next: map.get(cur)) {
                    degree.put(next, degree.get(next)-1);
                    if(degree.get(next) == 0)
                        queue.offer(next);
                }
            }
        }
        if(res.length() != degree.size()) return &quot;&quot;;
        return res.toString();
    }

</code></pre>

<h1 id="optimal-account-balancing:76dac5b6b228718d148e25520d85376a">Optimal Account Balancing</h1>

<p>A group of friends went on holiday and sometimes lent each other money. For example, Alice paid for Bill&rsquo;s lunch for $10. Then later Chris gave Alice $5 for a taxi ride. We can model each transaction as a tuple (x, y, z) which means person x gave person y $z. Assuming Alice, Bill, and Chris are person 0, 1, and 2 respectively (0, 1, 2 are the person&rsquo;s ID), the transactions can be represented as [[0, 1, 10], [2, 0, 5]].</p>

<p>Given a list of transactions between a group of people, return the minimum number of transactions required to settle the debt.</p>

<p>Note:</p>

<ol>
<li>A transaction will be given as a tuple (x, y, z). Note that x ≠ y and z &gt; 0.</li>
<li>Person&rsquo;s IDs may not be linear, e.g. we could have the persons 0, 1, 2 or we could also have the persons 0, 2, 6.</li>
</ol>

<h2 id="example-5:76dac5b6b228718d148e25520d85376a">Example</h2>

<pre><code>Input:
[[0,1,10], [1,0,1], [1,2,5], [2,0,5]]

Output:
1

Explanation:
Person #0 gave person #1 $10.
Person #1 gave person #0 $1.
Person #1 gave person #2 $5.
Person #2 gave person #0 $5.

Therefore, person #1 only need to give person #0 $4, and all debt is settled.

</code></pre>

<h2 id="solution-10:76dac5b6b228718d148e25520d85376a">Solution</h2>

<pre><code>    public int minTransfers(int[][] transactions) {
        HashMap&lt;Integer, Integer&gt; map = new HashMap();
        for(int[] trans: transactions) {
            map.put(trans[0], map.getOrDefault(trans[0], 0) - trans[2]);
            map.put(trans[1], map.getOrDefault(trans[1], 0) + trans[2]);
        }
        List&lt;Integer&gt; balance = new ArrayList();
        int index = 0;
        for(int v: map.values()) {
            if(v != 0)
                balance.add(v);
        }
        return cleanBalance(balance) + minMatch(balance, 0);
        
        
    }
    
    public int cleanBalance(List&lt;Integer&gt; balance) {
        Collections.sort(balance);
        int left = 0, right = balance.size()-1;
        int count = 0;
        while(left &lt; right) {
            if(- balance.get(left) == balance.get(right)) {
                count ++;
                balance.remove(right);
                balance.remove(left);
                right -= 2;
            } else if(- balance.get(left) &gt; balance.get(right))
                left ++;
            else
                right --;
        }
        return count;
    }
    
    public int minMatch(List&lt;Integer&gt; balance, int start) {
        int min = Integer.MAX_VALUE;
        while(start &lt; balance.size() &amp;&amp; balance.get(start) == 0)
            start ++;
        if(start == balance.size())
            return 0;
        int cur = balance.get(start);
        for(int i = start + 1; i &lt; balance.size(); i ++) {
            if(balance.get(i) * cur &lt; 0) {
                balance.set(i, balance.get(i) + cur);
                min = Math.min(min, 1 + minMatch(balance, start + 1));
                balance.set(i, balance.get(i) - cur);
            }
        }
        return min;
    }

</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://yjn93.github.io/dev/LeetCodeLocked/">
        LeetCodeLocked
      </a>
    </h1>

    <span class="post-date">Thu, Jan 5, 2017</span>

    

<h1 id="range-addition:391bf8c2ccd1748d42853cd47f55ff11">Range Addition</h1>

<p>Assume you have an array of length n initialized with all 0&rsquo;s and are given k update operations.</p>

<p>Each operation is represented as a triplet: [startIndex, endIndex, inc] which increments each element of subarray A[startIndex &hellip; endIndex] /(startIndex and endIndex inclusive) with inc.</p>

<p>Return the modified array after all k operations were executed.</p>

<h2 id="example:391bf8c2ccd1748d42853cd47f55ff11">Example</h2>

<pre><code>Given:

    length = 5,
    updates = [
        [1,  3,  2],
        [2,  4,  3],
        [0,  2, -2]
    ]

Output:

    [-2, 0, 3, 5, 3]
</code></pre>

<h2 id="explanation:391bf8c2ccd1748d42853cd47f55ff11">Explanation</h2>

<pre><code>Initial state:
[ 0, 0, 0, 0, 0 ]

After applying operation [1, 3, 2]:
[ 0, 2, 2, 2, 0 ]

After applying operation [2, 4, 3]:
[ 0, 2, 5, 5, 3 ]

After applying operation [0, 2, -2]:
[-2, 0, 3, 5, 3 ]
</code></pre>

<h2 id="solution:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<p>Only update the start and end+1 index every time is sufficient.</p>

<pre><code>    public int[] getModifiedArray(int length, int[][] updates) {
        int[] result = new int[length];
        for(int[] update: updates) {
            result[update[0]] += update[2];
            if(update[1] &lt; length-1)
                result[update[1]+1] -= update[2];
        }
        
        for(int i = 1; i &lt; length; i ++)
            result[i] += result[i-1];
        return result;
    }
</code></pre>

<h1 id="shortest-word-distance:391bf8c2ccd1748d42853cd47f55ff11">Shortest Word Distance</h1>

<p>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p>

<p>For example,</p>

<p>Assume that words = [&ldquo;practice&rdquo;, &ldquo;makes&rdquo;, &ldquo;perfect&rdquo;, &ldquo;coding&rdquo;, &ldquo;makes&rdquo;].</p>

<p>Given word1 = “coding”, word2 = “practice”, return 3.</p>

<p>Given word1 = &ldquo;makes&rdquo;, word2 = &ldquo;coding&rdquo;, return 1.</p>

<h2 id="solution-1:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<pre><code>    public int shortestDistance(String[] words, String word1, String word2) {
        int p1 = -1, p2 = -1;
        int min = words.length;
        for(int i = 0; i &lt; words.length; i ++) {
            if(words[i].equals(word1))
                p1 = i;
            if(words[i].equals(word2))
                p2 = i;
            if(p1 != -1 &amp;&amp; p2 != -1)
                min = Math.min(Math.abs(p2 - p1), min);
        }
        return min;
    }
</code></pre>

<h2 id="follow-up-1:391bf8c2ccd1748d42853cd47f55ff11">Follow up 1</h2>

<p>Now you are given the list of words and your method will be called repeatedly many times with different parameters. How would you optimize it?</p>

<p>Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list.</p>

<h3 id="solution-2:391bf8c2ccd1748d42853cd47f55ff11">Solution</h3>

<p>Use HashMap</p>

<pre><code>public class WordDistance {
    HashMap&lt;String, List&lt;Integer&gt;&gt; map;
    
    public WordDistance(String[] words) {
        map = new HashMap();
        for(int i = 0; i &lt; words.length; i ++) {
            if(!map.containsKey(words[i]))
                map.put(words[i], new ArrayList());
            map.get(words[i]).add(i);
        }
    }

    public int shortest(String word1, String word2) {
        int min = Integer.MAX_VALUE;
        for(int i: map.get(word1)) {
            for(int j: map.get(word2)) 
                min = Math.min(Math.abs(i - j), min);
        }
        return min;
    }
}EEEEEEE
</code></pre>

<h2 id="follow-up-2:391bf8c2ccd1748d42853cd47f55ff11">Follow up 2</h2>

<p>Now word1 could be the same as word2 and they represent two individual words in the list.</p>

<h3 id="solution-3:391bf8c2ccd1748d42853cd47f55ff11">Solution</h3>

<p>If we remove the boolean same variable, it can solve the basic problem.</p>

<pre><code>    public int shortestWordDistance(String[] words, String word1, String word2) {
        int index = -1;
        int min = words.length;
        boolean same = word1.equals(word2);
        for(int i = 0; i &lt; words.length; i ++) {
            if(words[i].equals(word1) || words[i].equals(word2)) {
                if(index != -1 &amp;&amp; (same || !words[index].equals(words[i]))){
                    min = Math.min(i - index, min);
                }
                index = i;
            }
        }
        return min;
    }

</code></pre>

<h1 id="zigzag-iterator:391bf8c2ccd1748d42853cd47f55ff11">Zigzag iterator</h1>

<p>Given two 1d vectors, implement an iterator to return their elements alternately.</p>

<p>For example, given two 1d vectors:</p>

<pre><code>v1 = [1, 2]
v2 = [3, 4, 5, 6]
By calling next repeatedly until hasNext returns false, the order of elements returned by next should be:
[1, 3, 2, 4, 5, 6]
</code></pre>

<p>Follow up: What if you are given k 1d vectors? How well can your code be extended to such cases?</p>

<pre><code>[1,2,3]
[4,5,6,7]
[8,9]
It should return [1,4,8,2,5,9,3,6,7].
</code></pre>

<h2 id="solution-4:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<p>Uses a linkedlist to store the iterators in different vectors. Every time we call next(), we pop an element from the list, and re-add it to the end to cycle through the lists.</p>

<pre><code>
public class ZigzagIterator {
    LinkedList&lt;Iterator&gt; list;
    
    public ZigzagIterator(List&lt;Integer&gt; v1, List&lt;Integer&gt; v2) {
        list = new LinkedList();
        if(!v1.isEmpty())
            list.add(v1.iterator());
        if(!v2.isEmpty())
            list.add(v2.iterator());
    }

    public int next() {
        Iterator cur = list.remove();
        int result = (int)cur.next();
        if(cur.hasNext()) list.add(cur);
        return result;
    }

    public boolean hasNext() {
        return !list.isEmpty();
    }
}

</code></pre>

<p>Many things need to be notice in code:</p>

<ul>
<li><p>For the member list, we need to specify its type as LinkedList, or Queue. If we use List<Iterator> list, we cannot use remove() or poll() method because they are not specified by interface List, but by Queue or Deque.</p></li>

<li><p>After we got the Iterator cur, we need to convert cur.next() to (int), otherwise it will raise Object cannot convert to int exception.</p></li>
</ul>

<h1 id="flip-game:391bf8c2ccd1748d42853cd47f55ff11">Flip Game</h1>

<p>You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two consecutive &ldquo;++&rdquo; into &ldquo;&ndash;&rdquo;. The game ends when a person can no longer make a move and therefore the other person will be the winner.</p>

<p>Write a function to determine if the starting player can guarantee a win.</p>

<p>For example, given s = &ldquo;++++&rdquo;, return true. The starting player can guarantee a win by flipping the middle &ldquo;++&rdquo; to become &ldquo;+&ndash;+&rdquo;.</p>

<h2 id="solution-5:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<pre><code>    Map&lt;String, Boolean&gt; winMap = new HashMap();
    
    public boolean canWin(String s) {
        if(winMap.containsKey(s)) return winMap.get(s);
        for(int i = -1; (i = s.indexOf(&quot;++&quot;, i + 1)) &gt;= 0; ) {
            String t = s.substring(0, i) + &quot;--&quot; + s.substring(i+2);
            if(!canWin(t)) {
                winMap.put(s, true);
                return true;
            }
        }
        winMap.put(s, false);
        return false;
    }

</code></pre>

<h1 id="generalized-abbreviation:391bf8c2ccd1748d42853cd47f55ff11">Generalized Abbreviation</h1>

<p>Write a function to generate the generalized abbreviations of a word.</p>

<h2 id="example-1:391bf8c2ccd1748d42853cd47f55ff11">Example</h2>

<p>Given word = &ldquo;word&rdquo;, return the following list (order does not matter):</p>

<pre><code>[&quot;word&quot;, &quot;1ord&quot;, &quot;w1rd&quot;, &quot;wo1d&quot;, &quot;wor1&quot;, &quot;2rd&quot;, &quot;w2d&quot;, &quot;wo2&quot;, &quot;1o1d&quot;, &quot;1or1&quot;, &quot;w1r1&quot;, &quot;1o2&quot;, &quot;2r1&quot;, &quot;3d&quot;, &quot;w3&quot;, &quot;4&quot;]

</code></pre>

<h2 id="solution-6:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<p>For each character, we can choose to put or not put it in the abbreviation. So we can use backtracking</p>

<pre><code>
    public List&lt;String&gt; generateAbbreviations(String word) {
        List&lt;String&gt; result = new ArrayList();
        dfs(result, new StringBuilder(), word, 0, 0);
        return result;
    }
    
    public void dfs(List&lt;String&gt; result, StringBuilder sb, String word, int pos, int count) {
        int len = sb.length();
        if(pos == word.length()) {
            if(count &gt; 0) sb.append(count);
            result.add(sb.toString());
        } else {
            dfs(result, sb, word, pos+1, count+1);
            if(count &gt; 0)
                sb.append(count);
            dfs(result, sb.append(word.charAt(pos)), word, pos+1, 0);
        }
        sb.setLength(len);
    }

</code></pre>

<h1 id="minimum-unique-word-abbreviation-hard:391bf8c2ccd1748d42853cd47f55ff11">Minimum Unique Word Abbreviation (Hard)</h1>

<p>Given a target string and a set of strings in a dictionary, find an abbreviation of this target string with the smallest possible length such that it does not conflict with abbreviations of the strings in the dictionary.</p>

<p>Each number or letter in the abbreviation is considered length = 1. For example, the abbreviation &ldquo;a32bc&rdquo; has length = 4.</p>

<h2 id="example-2:391bf8c2ccd1748d42853cd47f55ff11">Example</h2>

<pre><code>&quot;apple&quot;, [&quot;blade&quot;] -&gt; &quot;a4&quot; (because &quot;5&quot; or &quot;4e&quot; conflicts with &quot;blade&quot;)

&quot;apple&quot;, [&quot;plain&quot;, &quot;amber&quot;, &quot;blade&quot;] -&gt; &quot;1p3&quot; (other valid answers include &quot;ap3&quot;, &quot;a3e&quot;, &quot;2p2&quot;, &quot;3le&quot;, &quot;3l1&quot;).

</code></pre>

<h2 id="solution-7:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<p>Bit manipulation + DFS</p>

<p>The key idea of my solution is to preprocess the dictionary to transfer all the words to bit sequences (int):</p>

<p>Pick the words with same length as target string from the dictionary and compare the characters with target. If the characters are different, set the corresponding bit to 1, otherwise, set to 0.</p>

<p>Ex: &ldquo;abcde&rdquo;, [&ldquo;abxdx&rdquo;, &ldquo;xbcdx&rdquo;] =&gt; [00101, 10001]</p>

<p>The problem is now converted to find a bit mask that can represent the shortest abbreviation, so that for all the bit sequences in dictionary, mask &amp; bit sequence &gt; 0.</p>

<p>Ex: for [00101, 10001], the mask should be [00001]. if we mask the target string with it, we get &ldquo;4e&rdquo;, which is the abbreviation we are looking for.</p>

<p>To find the bit mask, we need to perform DFS with some optimizations. But which bits should be checked? We can perform &ldquo;or&rdquo; operation for all the bit sequences in the dictionary and do DFS for the &ldquo;1&rdquo; bits in the result.</p>

<p>Ex: 00101 | 10001 = 10101, so we only need to take care of the 1st, 3rd, and 5th bit.</p>

<pre><code>    int cand;  // candidate bits in mask that can be set to 1
    int n, bn;  
    int minLen, minAbbr;
    List&lt;Integer&gt; dict = new ArrayList(); //store reversed bit representation of words
    
    public String minAbbreviation(String target, String[] dictionary) {
        n = target.length();
        bn = 1 &lt;&lt; n;
        minLen = Integer.MAX_VALUE;
        buildBitDict(target, dictionary);
        
        dfs(1, 0);
        
        //Reconstruct from minAbbr (minAbbr is a reversed representation of abbr) 
        int count = 0;
        StringBuilder res = new StringBuilder();
        for(int i = 0; i &lt; n; i ++) {
            if(((1 &lt;&lt; i) &amp; minAbbr) == 0) 
                count ++;
            else {
                if(count &gt; 0)
                    res.append(count);
                res.append(target.charAt(i));
                count = 0;
            }
        }
        if(count &gt; 0) res.append(count);
        return res.toString();
        
    }
    
    public void dfs(int bit, int mask) {
        int len = abbrLen(mask);
        if(len &gt;= minLen) return;
        boolean match = true;
        for(int word: dict) {
            if((word &amp; mask) == 0){
                match = false;
                break;
            }
        }
        if(match) {
            minLen = len;
            minAbbr = mask;
        } else {
            for(int b = bit; b &lt; bn; b &lt;&lt;= 1) {
                if((b &amp; cand) != 0)
                    dfs(b &lt;&lt; 1, mask + b);
            }
        }
    }
    
    public int abbrLen(int mask) {
        int count = n;
        for(int b = 3; b &lt; bn; b &lt;&lt;= 1) {
            if((b &amp; mask) == 0)
                count --;
        }
        return count;
    }
    
    public void buildBitDict(String target, String[] dictionary) {
        cand = 0;
        for(String s: dictionary) {
            if(s.length() != n) continue;
            int word = 0;
            for(int i = 0; i &lt; n; i ++) {
                if(s.charAt(i) != target.charAt(i))
                    word |= 1 &lt;&lt; i;
            }
            dict.add(word);
            cand |= word;
        }        
    }

</code></pre>

<h1 id="maximum-size-subarray-sum-equals-k:391bf8c2ccd1748d42853cd47f55ff11">Maximum Size Subarray Sum Equals k</h1>

<p>Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn&rsquo;t one, return 0 instead.</p>

<pre><code>
Example 1:
Given nums = [1, -1, 5, -2, 3], k = 3,
return 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longest)

Example 2:
Given nums = [-2, -1, 2, 1], k = 1,
return 2. (because the subarray [-1, 2] sums to 1 and is the longest

</code></pre>

<h2 id="solution-8:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<p>I didn&rsquo;t come up with the idea of using map.</p>

<pre><code>    public int maxSubArrayLen(int[] nums, int k) {
        int max = 0, sum = 0;
        HashMap&lt;Integer, Integer&gt; map = new HashMap();
        for(int i = 0; i &lt; nums.length; i ++) {
            sum += nums[i];
            if(sum == k) 
                max = i + 1;
            else if(map.containsKey(sum - k))
                max = Math.max(max, i - map.get(sum - k));
            if(!map.containsKey(sum))
                map.put(sum, i);
        }
        return max;
    }

</code></pre>

<h1 id="factor-combinations:391bf8c2ccd1748d42853cd47f55ff11">Factor Combinations</h1>

<p>Numbers can be regarded as product of its factors. Write a function that takes an integer n and return all possible combinations of its factors,</p>

<h2 id="example-3:391bf8c2ccd1748d42853cd47f55ff11">Example</h2>

<pre><code>input: 1
output: []

input: 37
output: []

input: 12
output:
[
  [2, 6],
  [2, 2, 3],
  [3, 4]
]

input: 32
output:
[
  [2, 16],
  [2, 2, 8],
  [2, 2, 2, 4],
  [2, 2, 2, 2, 2],
  [2, 4, 4],
  [4, 8]
]

</code></pre>

<h2 id="solution-9:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<p>Backtracking, similar to combination sum.</p>

<pre><code>    public List&lt;List&lt;Integer&gt;&gt; getFactors(int n) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList();
        helper(result, new ArrayList(), n, 2);
        return result;
    }
    
    public void helper(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; cur, int n, int start) {
        for(int i = start; i &lt;= n / i; i ++) {
            if(n % i == 0) {
                cur.add(i);
                cur.add(n/i);
                result.add(new ArrayList(cur));
                cur.remove(cur.size()-1);
                helper(result, cur, n/i, i);
                cur.remove(cur.size()-1);
            }
        }
    }

</code></pre>

<h1 id="bomb-enemy:391bf8c2ccd1748d42853cd47f55ff11">Bomb Enemy</h1>

<p>Given a 2D grid, each cell is either a wall &lsquo;W&rsquo;, an enemy &lsquo;E&rsquo; or empty &lsquo;0&rsquo; (the number zero), return the maximum enemies you can kill using one bomb.</p>

<p>The bomb kills all the enemies in the same row and column from the planted point until it hits the wall since the wall is too strong to be destroyed.</p>

<p>Note that you can only put the bomb at an empty cell.</p>

<h2 id="example-4:391bf8c2ccd1748d42853cd47f55ff11">Example</h2>

<pre><code>For the given grid

0 E 0 0
E 0 W E
0 E 0 0

return 3. (Placing a bomb at (1,1) kills 3 enemies)
</code></pre>

<h2 id="solution-10:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<p>Using dp, only need to record number of enemies in current row and every column. If encounter a wall, update the values.</p>

<pre><code>    public int maxKilledEnemies(char[][] grid) {
        if(grid == null || grid.length == 0 || grid[0].length == 0)
            return 0;
        int m = grid.length, n = grid[0].length;
        int row = 0;
        int[] col = new int[n];
        int max = 0;
        for(int i = 0; i &lt; m; i ++) {
            for(int j = 0; j &lt; n; j ++) {
                if(grid[i][j] == 'W') continue;
                if(j == 0 || grid[i][j-1] == 'W') {
                    row = 0;
                    for(int k = j; k &lt; n &amp;&amp; grid[i][k] != 'W'; k ++)
                        row += grid[i][k] == 'E' ? 1 : 0;
                }
                if(i == 0 || grid[i-1][j] == 'W') {
                    col[j] = 0;
                    for(int k = i; k &lt; m &amp;&amp; grid[k][j] != 'W'; k ++)
                        col[j] += grid[k][j] == 'E' ? 1 : 0;
                }
                if(grid[i][j] == '0')
                    max = Math.max(row + col[j], max);
            }
        }
        return max;
    }

</code></pre>

<h1 id="inorder-successor-in-bst:391bf8c2ccd1748d42853cd47f55ff11">Inorder Successor in BST</h1>

<p>Given a binary search tree and a node in it, find the in-order successor of that node in the BST.</p>

<p>Note: If the given node has no in-order successor in the tree, return null.</p>

<h2 id="solution-11:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<pre><code>	//Iterative
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        TreeNode cur = root;
        TreeNode result = null;
        while(cur != null) {
            if(cur.val &gt; p.val) {
                result = cur;
                cur = cur.left;
            } else {
                cur = cur.right;
            }
        }
        return result;
    }

	// Recursive
	public TreeNode successor(TreeNode root, TreeNode p) {
  		if (root == null)
    	return null;

  		if (root.val &lt;= p.val) {
    		return successor(root.right, p);
  		} else {
    		TreeNode left = successor(root.left, p);
    		return (left != null) ? left : root;
  		}
	}	
</code></pre>

<h1 id="find-the-celebrity:391bf8c2ccd1748d42853cd47f55ff11">Find the Celebrity</h1>

<p>Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.</p>

<p>Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: &ldquo;Hi, A. Do you know B?&rdquo; to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).</p>

<p>You are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n), your function should minimize the number of calls to knows.</p>

<p>Note: There will be exactly one celebrity if he/she is in the party. Return the celebrity&rsquo;s label if there is a celebrity in the party. If there is no celebrity, return -1.</p>

<h2 id="solution-12:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<pre><code>    public int findCelebrity(int n) {
        if(n &lt;= 1) return n-1;
        int cur = 0;
        for(int i = 1; i &lt; n; i ++) {
            if(knows(cur, i)) {
                    cur = i;
            }
        }
        for(int i = 0; i &lt; n; i ++) {
            if(i != cur &amp;&amp; (knows(cur, i) || !knows(i, cur)))
                return -1;
        }
        return cur;
    }

</code></pre>

<h1 id="palindrome-permutation:391bf8c2ccd1748d42853cd47f55ff11">Palindrome Permutation</h1>

<p>Given a string, determine if a permutation of the string could form a palindrome.</p>

<p>For example,
&ldquo;code&rdquo; -&gt; False, &ldquo;aab&rdquo; -&gt; True, &ldquo;carerac&rdquo; -&gt; True.</p>

<h2 id="solution-13:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<p>Use a set.</p>

<pre><code>    public boolean canPermutePalindrome(String s) {
        Set&lt;Character&gt; set = new HashSet();
        for(int i = 0; i &lt; s.length(); i ++) {
            if(!set.add(s.charAt(i)))
                set.remove(s.charAt(i));
        }
        return set.size() == 0 || set.size() == 1;
    }

</code></pre>

<h1 id="palindrome-permutation-ii:391bf8c2ccd1748d42853cd47f55ff11">Palindrome Permutation II</h1>

<p>Given a string s, return all the palindromic permutations (without duplicates) of it. Return an empty list if no palindromic permutation could be form.</p>

<p>For example:</p>

<p>Given s = &ldquo;aabb&rdquo;, return [&ldquo;abba&rdquo;, &ldquo;baab&rdquo;].</p>

<p>Given s = &ldquo;abc&rdquo;, return [].</p>

<h2 id="solution-14:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<pre><code>    public List&lt;String&gt; generatePalindromes(String s) {
        List&lt;String&gt; result = new ArrayList();
        if(s == null || s.length() == 0)
            return result;
        Set&lt;Character&gt; set = new HashSet();
        List&lt;Character&gt; sb = new ArrayList();
        for(int i = 0; i &lt; s.length(); i ++) {
            if(!set.add(s.charAt(i))) {
                set.remove(s.charAt(i));
                sb.add(s.charAt(i));
            }
        }
        System.out.println(sb.toString());
        if(set.size() != 0 &amp;&amp; set.size() != 1)
            return result;
        String mid = set.size() == 1 ? set.iterator().next().toString() : &quot;&quot;;
        Collections.sort(sb);
        helper(result, new StringBuilder(), mid, sb, new boolean[sb.size()]);
        return result;        
    }
    
    public void helper(List&lt;String&gt; result, StringBuilder cur, String mid, List&lt;Character&gt; sb, boolean[] used) {
        if(cur.length() == sb.size()) {
            result.add(cur.toString() + mid + cur.reverse().toString());
            // reverse back is very important!!!
            cur.reverse();
            return;
        }
        for(int i = 0; i &lt; sb.size(); i ++) {
            if(used[i]) continue;
            if(i &gt; 0 &amp;&amp; sb.get(i) == sb.get(i-1) &amp;&amp; !used[i-1]) continue;
            cur.append(sb.get(i));
            used[i] = true;
            helper(result, cur, mid, sb, used);
            cur.deleteCharAt(cur.length()-1);
            used[i] = false;
        }
    }

</code></pre>

<h1 id="one-edit-distance:391bf8c2ccd1748d42853cd47f55ff11">One Edit Distance</h1>

<p>Given two strings S and T, determine if they are both one edit distance apart.</p>

<h2 id="solution-15:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<pre><code>
//  There're 3 possibilities to satisfy one edit distance apart: 
  
//  1) Replace 1 char:
// 	  s: a B c
// 	  t: a D c
//  2) Delete 1 char from s: 
//	  s: a D  b c
//	  t: a    b c
//  3) Delete 1 char from t
//	  s: a   b c
//	  t: a D b c
 

    public boolean isOneEditDistance(String s, String t) {
        if(Math.abs(s.length() - t.length()) &gt; 1)
            return false;
        for(int i = 0; i &lt; Math.min(s.length(), t.length()); i ++) {
            if(s.charAt(i) != t.charAt(i)) {
                if(s.length() == t.length()) 
                    return s.substring(i+1).equals(t.substring(i+1));
                else if(s.length() &gt; t.length())
                    return s.substring(i+1).equals(t.substring(i));
                else 
                    return s.substring(i).equals(t.substring(i+1));
            }
        }
		//All previous chars are the same, the only possibility is deleting the end char in the longer one of s and t 
        return Math.abs(s.length() - t.length()) == 1;
    }
</code></pre>

<h1 id="line-reflection:391bf8c2ccd1748d42853cd47f55ff11">Line Reflection</h1>

<p>Given n points on a 2D plane, find if there is such a line parallel to y-axis that reflect the given points.</p>

<p>Example 1:
Given points = [[1,1],[-1,1]], return true.</p>

<p>Example 2:
Given points = [[1,1],[-1,-1]], return false.</p>

<h2 id="solution-16:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<ol>
<li>Find the smallest and largest x-value for all points.</li>
<li>If there is a line then it should be at y = (minX + maxX) / 2.</li>
<li>For each point, make sure that it has a reflected point in the opposite side.</li>
</ol>

<p>I used HashMap because I didn&rsquo;t consider the case that several points can share the same x-index.</p>

<p>For example: [[1,2],[2,2],[1,4],[2,4]]</p>

<pre><code>    public boolean isReflected(int[][] points) {
        HashSet&lt;Integer&gt; set = new HashSet();
        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
        for(int[] point: points) {
            set.add(Arrays.hashCode(point));
            min = Math.min(min, point[0]);
            max = Math.max(max, point[0]);
        }
        int sum = max + min;
        for(int[] point: points) {
            if(!set.contains(Arrays.hashCode(new int[]{sum - point[0], point[1]})))
                return false;
        }
        return true;
    }

</code></pre>

<h1 id="largest-bst-subtree:391bf8c2ccd1748d42853cd47f55ff11">Largest BST Subtree</h1>

<p>Given a binary tree, find the largest subtree which is a Binary Search Tree (BST), where largest means subtree with largest number of nodes in it.</p>

<h2 id="solution-17:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<p>Similar to LeetCode 98. Validate Binary Search Tree</p>

<pre><code>    int max = 0;
    
    class TreeNodeBound {
        int size;
        int left;
        int right;
        
        public TreeNodeBound(int size, int left, int right) {
            this.size = size;
            this.left = left;
            this.right = right;
        }
    }
    
    public int largestBSTSubtree(TreeNode root) {
        dfs(root);
        return max;
    }
    
    public TreeNodeBound dfs(TreeNode root) {
        if(root == null) return new TreeNodeBound(0, Integer.MAX_VALUE, Integer.MIN_VALUE);
        TreeNodeBound left = dfs(root.left);
        TreeNodeBound right = dfs(root.right);
        if(left.size == -1 || right.size == -1 || left.right &gt;= root.val || right.left &lt;= root.val)
            return new TreeNodeBound(-1, 0, 0);
        int size = left.size + right.size + 1;
        max = Math.max(max, size);
        return new TreeNodeBound(size, Math.min(left.left, root.val), Math.max(right.right, root.val));
    }

</code></pre>

<h1 id="sentence-screen-fitting:391bf8c2ccd1748d42853cd47f55ff11">Sentence Screen Fitting</h1>

<p>Given a rows x cols screen and a sentence represented by a list of non-empty words, find how many times the given sentence can be fitted on the screen.</p>

<p>Note:</p>

<ol>
<li>A word cannot be split into two lines.</li>
<li>The order of words in the sentence must remain unchanged.</li>
<li>Two consecutive words in a line must be separated by a single space.</li>
<li>Total words in the sentence won&rsquo;t exceed 100.</li>
<li>Length of each word is greater than 0 and won&rsquo;t exceed 10.</li>
<li>1 ≤ rows, cols ≤ 20,000.</li>
</ol>

<h2 id="solution-18:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<p>I used brute force which exceeds time limit. We can use a dp like solution which keep track of the row  starting with every index of the sentence.</p>

<pre><code>    public int wordsTyping(String[] sentence, int rows, int cols) {
        int[] nextIdx = new int[sentence.length];
        int[] times = new int[sentence.length];
        for(int i = 0; i &lt; sentence.length; i ++) {
            int cur = i;
            int j = 0;
            while(j + sentence[cur].length() &lt;= cols) {
                j += sentence[cur].length() + 1;
                cur ++;
                if(cur == sentence.length){
                    cur = 0;
                    times[i] ++;
                }
            }
            nextIdx[i] = cur;
        }
        int count = 0;
        int index = 0;
        for(int i = 0; i &lt; rows; i ++) {
            count += times[index];
            index = nextIdx[index];
        }

        return count;
    }

</code></pre>

<h1 id="encode-and-decode-strings:391bf8c2ccd1748d42853cd47f55ff11">Encode and Decode Strings</h1>

<p>Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings.</p>

<h2 id="solution-19:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<pre><code>    // Encodes a list of strings to a single string.
    public String encode(List&lt;String&gt; strs) {
        StringBuilder sb = new StringBuilder();
        for(String str: strs) {
            sb.append(str.length() + &quot;/&quot; + str);
        }
        return sb.toString();
    }

    // Decodes a single string to a list of strings.
    public List&lt;String&gt; decode(String s) {
        List&lt;String&gt; result = new ArrayList();
        int index = 0;
        while(index &lt; s.length()) {
            int slash = s.indexOf(&quot;/&quot;, index);
            int len = Integer.valueOf(s.substring(index, slash));
            result.add(s.substring(slash + 1, slash + len + 1));
            index = slash + len + 1;
        }
        return result;
    }

</code></pre>

<h1 id="sequence-reconstruction:391bf8c2ccd1748d42853cd47f55ff11">Sequence Reconstruction</h1>

<p>Check whether the original sequence org can be uniquely reconstructed from the sequences in seqs. The org sequence is a permutation of the integers from 1 to n, with 1 ≤ n ≤ 104. Reconstruction means building a shortest common supersequence of the sequences in seqs (i.e., a shortest sequence so that all sequences in seqs are subsequences of it). Determine whether there is only one sequence that can be reconstructed from seqs and it is the org sequence.</p>

<h2 id="example-5:391bf8c2ccd1748d42853cd47f55ff11">Example</h2>

<pre><code>Input:
org: [1,2,3], seqs: [[1,2],[1,3]]

Output:
false

Explanation:
[1,2,3] is not the only one sequence that can be reconstructed, because [1,3,2] is also a valid sequence that can be reconstructed.

Input:
org: [1,2,3], seqs: [[1,2]]

Output:
false

Explanation:
The reconstructed sequence can only be [1,2].

Input:
org: [1,2,3], seqs: [[1,2],[1,3],[2,3]]

Output:
true

Explanation:
The sequences [1,2], [1,3], and [2,3] can uniquely reconstruct the original sequence [1,2,3].

Input:
org: [4,1,5,2,6,3], seqs: [[5,2,6,3],[4,1,5,2]]

Output:
true

</code></pre>

<h2 id="solution-20:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<p>BFS topological sort</p>

<pre><code>    public boolean sequenceReconstruction(int[] org, List&lt;List&lt;Integer&gt;&gt; seqs) {
        Map&lt;Integer, Set&lt;Integer&gt;&gt; adjs = new HashMap();
        Map&lt;Integer, Integer&gt; inDegree = new HashMap();
        
        for(List&lt;Integer&gt; seq: seqs) {
            if(seq.size() == 1) {
                if(!adjs.containsKey(seq.get(0))) {
                    adjs.put(seq.get(0), new HashSet());
                    inDegree.put(seq.get(0), 0);
                }
            } 
            for(int i = 0; i &lt; seq.size()-1; i ++) {
                if(!adjs.containsKey(seq.get(i))) {
                    adjs.put(seq.get(i), new HashSet());
                    inDegree.put(seq.get(i), 0);
                }
                if(!adjs.containsKey(seq.get(i+1))) {
                    adjs.put(seq.get(i+1), new HashSet());
                    inDegree.put(seq.get(i+1), 0);
                }
                if(adjs.get(seq.get(i)).add(seq.get(i+1)))
                    inDegree.put(seq.get(i+1), inDegree.get(seq.get(i+1))+1);
            }
        }
        
        Queue&lt;Integer&gt; queue = new LinkedList();
        for(Map.Entry&lt;Integer, Integer&gt; entry: inDegree.entrySet()) {
            if(entry.getValue() == 0)
                queue.offer(entry.getKey());
        }
        
        int index = 0;
        
        while(!queue.isEmpty()) {
            if(queue.size() &gt; 1) return false;
            int cur = queue.poll();
            if(index == org.length || org[index ++] != cur)
                return false;
            for(int next: adjs.get(cur)) {
                inDegree.put(next, inDegree.get(next)-1);
                if(inDegree.get(next) == 0)
                    queue.offer(next);
            }
        }
        return org.length == index &amp;&amp; index == adjs.size();
    }

</code></pre>

<h1 id="strobogrammatic-number:391bf8c2ccd1748d42853cd47f55ff11">Strobogrammatic Number</h1>

<p>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).</p>

<p>Write a function to determine if a number is strobogrammatic. The number is represented as a string.</p>

<p>For example, the numbers &ldquo;69&rdquo;, &ldquo;88&rdquo;, and &ldquo;818&rdquo; are all strobogrammatic.</p>

<h2 id="solution-21:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<pre><code>    public boolean isStrobogrammatic(String num) {
        for(int i = 0, j = num.length()-1; i &lt;= j; i++, j--) {
            if(!&quot;00 11 88 696&quot;.contains(num.charAt(i) + &quot;&quot; + num.charAt(j)))
                return false;
        }
        return true;
    }

</code></pre>

<h1 id="strobogrammatic-number-ii:391bf8c2ccd1748d42853cd47f55ff11">Strobogrammatic Number II</h1>

<p>Find all strobogrammatic numbers that are of length = n.</p>

<p>For example,</p>

<p>Given n = 2, return [&ldquo;11&rdquo;,&ldquo;69&rdquo;,&ldquo;88&rdquo;,&ldquo;96&rdquo;].</p>

<h2 id="solution-22:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<pre><code>    int[][] map = {{0,0},{1,1},{8,8},{6,9},{9,6}};
    
    public List&lt;String&gt; findStrobogrammatic(int n) {
        List&lt;String&gt; result = new ArrayList();
        if(n == 0) return result;
        if(n == 1) {
            result.add(&quot;0&quot;);
            result.add(&quot;1&quot;);
            result.add(&quot;8&quot;);
            return result;
        }
        if(n % 2 == 0)
            helper(result, &quot;&quot;, n);
        else {
            helper(result, &quot;0&quot;, n - 1);
            helper(result, &quot;1&quot;, n - 1);
            helper(result, &quot;8&quot;, n - 1);
        }
        return result;
    }
    
    public void helper(List&lt;String&gt; result, String cur, int n) {
        if(n == 0) {
            if(cur.charAt(0) != '0')
                result.add(cur);
            return;
        }
        int len = cur.length();
        for(int[] num: map) {
            cur = num[0] + cur + num[1];
            helper(result, cur, n - 2);
            cur = cur.substring(1, len+1);
        }
    }

</code></pre>

<h1 id="strobogrammatic-number-iii:391bf8c2ccd1748d42853cd47f55ff11">Strobogrammatic Number III</h1>

<p>Write a function to count the total strobogrammatic numbers that exist in the range of low &lt;= num &lt;= high.</p>

<p>For example,</p>

<p>Given low = &ldquo;50&rdquo;, high = &ldquo;100&rdquo;, return 3. Because 69, 88, and 96 are three strobogrammatic numbers.</p>

<h2 id="solution-23:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<pre><code>    int[][] map = {{0,0}, {1,1}, {8,8}, {6,9}, {9,6}};
    int count = 0;
    
    public int strobogrammaticInRange(String low, String high) {
        int min = low.length(), max = high.length();
        for(int n = min; n &lt;= max; n ++) {
            if(n % 2 == 0)
                helper(&quot;&quot;, low, high, n);
            else {
                helper(&quot;0&quot;, low, high, n-1);
                helper(&quot;1&quot;, low, high, n-1);
                helper(&quot;8&quot;, low, high, n-1);
            }
        }
        return count;
    }
    
    public void helper(String cur, String low, String high, int n) {
        int len = cur.length();
        if(n == 0) {
            if(len &gt; 1 &amp;&amp; cur.charAt(0) == '0') return;
            if((len == low.length() &amp;&amp; cur.compareTo(low) &lt; 0) ||
                (len == high.length() &amp;&amp; cur.compareTo(high) &gt; 0))
                return;
            count ++;
            return;
        }
        for(int[] num: map) {
            cur = num[0] + cur + num[1];
            helper(cur, low, high, n-2);
            cur = cur.substring(1, len+1);
        }
    }

</code></pre>

<h1 id="read-n-characters-given-read4:391bf8c2ccd1748d42853cd47f55ff11">Read N Characters Given Read4</h1>

<p>The API: int read4(char *buf) reads 4 characters at a time from a file.</p>

<p>The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.</p>

<p>By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.</p>

<h2 id="solution-24:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<pre><code>    public int read(char[] buf, int n) {
        char[] temp = new char[4];
        int count = 0;
        boolean eof = false;
        while(count &lt; n &amp;&amp; !eof) {
            int cur = read4(temp);
            eof = cur &lt; 4;
            int len = Math.min(cur, n - count);
            for(int i = 0; i &lt; len; i ++) {
                buf[count ++] = temp[i];
            }
        }
        return count;
    }

</code></pre>

<h1 id="read-n-characters-given-read4-ii-call-multiple-times:391bf8c2ccd1748d42853cd47f55ff11">Read N Characters Given Read4 II - Call multiple times</h1>

<p>The read function may be called multiple times.</p>

<h2 id="solution-25:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<pre><code>     int index = 0;
     int count = 0;
     char[] next = new char[4];
     
    public int read(char[] buf, int n) {
        int p = 0;
        while(p &lt; n) {
            if(index == 0)
                count = read4(next);
            if(count == 0) break;
            while(p &lt; n &amp;&amp; index &lt; count)
                buf[p ++] = next[index ++];
            if(index == count) index = 0;
        }
        return p;
    }
</code></pre>

<h1 id="group-shifted-strings:391bf8c2ccd1748d42853cd47f55ff11">Group Shifted Strings</h1>

<p>Given a string, we can &ldquo;shift&rdquo; each of its letter to its successive letter, for example: &ldquo;abc&rdquo; -&gt; &ldquo;bcd&rdquo;. We can keep &ldquo;shifting&rdquo; which forms the sequence:</p>

<p>&ldquo;abc&rdquo; -&gt; &ldquo;bcd&rdquo; -&gt; &hellip; -&gt; &ldquo;xyz&rdquo;</p>

<p>Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence.</p>

<h2 id="example-6:391bf8c2ccd1748d42853cd47f55ff11">Example</h2>

<pre><code>[&quot;abc&quot;, &quot;bcd&quot;, &quot;acef&quot;, &quot;xyz&quot;, &quot;az&quot;, &quot;ba&quot;, &quot;a&quot;, &quot;z&quot;]

[
  [&quot;abc&quot;,&quot;bcd&quot;,&quot;xyz&quot;],
  [&quot;az&quot;,&quot;ba&quot;],
  [&quot;acef&quot;],
  [&quot;a&quot;,&quot;z&quot;]
]
Show Company Tags
Show Tags
Show Similar Problems


</code></pre>

<h2 id="solution-26:391bf8c2ccd1748d42853cd47f55ff11">Solution</h2>

<pre><code>    public List&lt;List&lt;String&gt;&gt; groupStrings(String[] strings) {
        Map&lt;String, List&lt;String&gt;&gt; map = new HashMap();
        Arrays.sort(strings);
        for(String cur: strings) {
            int offset = cur.charAt(0) - 'a';
            String key = &quot;&quot;;
            for(int i = 0; i &lt; cur.length(); i ++) {
                char c = (char)(cur.charAt(i) - offset);
                if(c &lt; 'a')
                    c += 26;
                key += c;
            }
            if(!map.containsKey(key))
                map.put(key, new ArrayList());
            map.get(key).add(cur);
        }
        return new ArrayList(map.values());
    }
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://yjn93.github.io/dev/UnionFind/">
        Union Find for board connection
      </a>
    </h1>

    <span class="post-date">Tue, Jan 3, 2017</span>

    

<h1 id="union-find:7b5dfc6ca8814f1e54ab64455253b7f0">Union Find</h1>

<p>This data structure can be used to solve dynamic connectivity problem. Usually, if we care about the path between two connected node, we need to use dfs. However, for checking the connectivity itself, union find can work. Also, dfs is suitable for static graph while union find is better for changing graph.</p>

<h2 id="initialization:7b5dfc6ca8814f1e54ab64455253b7f0">Initialization</h2>

<pre><code>int[] unionSet;
// Initialize the union root of every element to be itself.
unionSet[i] = i;

// Sometime use another array to record the size of the union for the purpose of weighted union
int[] size = new int[unionSet.length];

</code></pre>

<h2 id="weighted-union:7b5dfc6ca8814f1e54ab64455253b7f0">Weighted Union</h2>

<pre><code>    private void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
		if(size[rootP] &lt; size[rootQ]) {
        	unionSet[rootP] = rootQ;
			size[rootQ] += size[rootP];
		} else {
			unionSet[rootQ] = rootP;
			size[rootP] += size[rootQ];
		}
    }

</code></pre>

<h2 id="find-with-path-compression:7b5dfc6ca8814f1e54ab64455253b7f0">Find with path compression</h2>

<p>Two ways: recursion and loop</p>

<pre><code>// recursion: set the height of the union to be 1
    private int find(int p) {
        if(unionSet[p] == p)
            return p;
        unionSet[p] = find(unionSet[p]);
        return unionSet[p];
    }

// loop: set the parent of a node to be its grandparent
    private int find(int p) {
        while(unionSet[p] != p){
           	unionSet[p] = unionSet[unionSet[p]];
			p = unionSet[p];
		}
        return p;
    }
</code></pre>

<h1 id="surrounded-regions:7b5dfc6ca8814f1e54ab64455253b7f0">Surrounded Regions</h1>

<ul>
<li><a href="https://leetcode.com/problems/surrounded-regions/">LeetCode 130</a></li>
</ul>

<p>Given a 2D board containing &lsquo;X&rsquo; and &lsquo;O&rsquo; (the letter O), capture all regions surrounded by &lsquo;X&rsquo;.</p>

<p>A region is captured by flipping all &lsquo;O&rsquo;s into &lsquo;X&rsquo;s in that surrounded region.</p>

<h2 id="example:7b5dfc6ca8814f1e54ab64455253b7f0">Example</h2>

<pre><code>X X X X
X O O X
X X O X
X O X X

</code></pre>

<p>After running your function, the board should be:</p>

<pre><code>X X X X
X X X X
X X X X
X O X X

</code></pre>

<h2 id="solution-with-union-find:7b5dfc6ca8814f1e54ab64455253b7f0">Solution with union find</h2>

<p>There is another solution which first use dfs from the edges to turn every edgeO to &lsquo;1&rsquo;, then turn every not-transfered &lsquo;O&rsquo; to &lsquo;X&rsquo;, then turn all &lsquo;1&rsquo; back to &lsquo;O&rsquo;. Here, we give the union find solution.</p>

<pre><code>public class Solution {
    int[] unionSet;
    boolean[] hasEdgeO;
    
    public void solve(char[][] board) {
        if(board == null || board.length == 0 || board[0].length == 0)
            return;
        int m = board.length, n = board[0].length;
        unionSet = new int[m * n];
        hasEdgeO = new boolean[unionSet.length];
        for(int i = 0; i &lt; m; i ++) {
            for(int j = 0; j &lt; n; j ++) {
                int index = i * n + j;
                unionSet[index] = index;
                if(board[i][j] == 'X') continue;
                if(i == 0 || j == 0 || i == m-1 || j == n-1)
                    hasEdgeO[index] = true;
                if(i &gt; 0 &amp;&amp; board[i-1][j] == 'O')
                    union(index, index-n);
                if(j &gt; 0 &amp;&amp; board[i][j-1] == 'O')
                    union(index, index-1);
            }
        }
        for(int i = 1; i &lt; m; i ++) {
            for(int j = 1; j &lt; n; j ++) {
                if(board[i][j] == 'O' &amp;&amp; !hasEdgeO[find(i * n + j)])
                    board[i][j] = 'X';
            }   
        }
    }
    
    private int find(int p) {
        if(unionSet[p] == p)
            return p;
        unionSet[p] = find(unionSet[p]);
        return unionSet[p];
    }
    
    private void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        unionSet[rootP] = rootQ;
        hasEdgeO[rootQ] = hasEdgeO[rootP] || hasEdgeO[rootQ];
    }
}
</code></pre>

<h1 id="number-of-connected-components-in-an-undirected-graph:7b5dfc6ca8814f1e54ab64455253b7f0">Number of Connected Components in an Undirected Graph</h1>

<ul>
<li><a href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/">LeetCode 323</a></li>
</ul>

<p>Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.</p>

<h2 id="example-1:7b5dfc6ca8814f1e54ab64455253b7f0">Example</h2>

<pre><code>	 0          3
     |          |
     1 --- 2    4
Given n = 5 and edges = [[0, 1], [1, 2], [3, 4]], return 2.

     0           4
     |           |
     1 --- 2 --- 3
Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]], return 1.

</code></pre>

<h2 id="solution-with-straitforward-dfs:7b5dfc6ca8814f1e54ab64455253b7f0">Solution with straitforward dfs</h2>

<pre><code>    public int countComponents(int n, int[][] edges) {
        boolean[] visited = new boolean[n];
        List&lt;Integer&gt;[] adjs = new List[n];
        for(int i = 0; i &lt; n; i ++)
            adjs[i] = new ArrayList();
        for(int[] edge: edges) {
            if(!adjs[edge[0]].contains(edge[1]))
                adjs[edge[0]].add(edge[1]);
            if(!adjs[edge[1]].contains(edge[0]))
                adjs[edge[1]].add(edge[0]);
        }
        int count = 0;
        for(int i = 0; i &lt; n; i ++) {
            if(!visited[i]) {
                dfs(adjs, visited, i);
                count ++;
            }
        }
        return count;
    }
    
    public void dfs(List&lt;Integer&gt;[] adjs, boolean[] visited, int cur) {
        
        visited[cur] = true;
        for(int neighbor: adjs[cur])
            if(!visited[neighbor])
                dfs(adjs, visited, neighbor);
    }

</code></pre>

<h2 id="solution-with-union-find-1:7b5dfc6ca8814f1e54ab64455253b7f0">Solution with Union-Find</h2>

<pre><code>    public int countComponents(int n, int[][] edges) {
        int[] root = new int[n];
        for(int i = 0; i &lt; n; i ++) {
            root[i] = i;
        }
        for(int[] edge: edges) {
            int i = find(root, edge[0]);
            int j = find(root, edge[1]);
            if(i != j) {
                root[i] = j;
                n --;
            }
        }
        return n;
    }
    
    public int find(int[] root, int p) {
        if(root[p] == p)
            return p;
        root[p] = find(root, root[p]);
        return root[p];
    }

</code></pre>

<h1 id="number-of-islands:7b5dfc6ca8814f1e54ab64455253b7f0">Number of Islands</h1>

<ul>
<li><a href="https://leetcode.com/problems/number-of-islands/">LeetCode</a></li>
</ul>

<p>Given a 2d grid map of &lsquo;1&rsquo;s (land) and &lsquo;0&rsquo;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>

<h2 id="example-2:7b5dfc6ca8814f1e54ab64455253b7f0">Example</h2>

<pre><code>11110
11010
11000
00000

Answer: 1

11000
11000
00100
00011

Answer: 3

</code></pre>

<h2 id="dfs-solution:7b5dfc6ca8814f1e54ab64455253b7f0">DFS solution</h2>

<pre><code>    public int numIslands(char[][] grid) {
        int count = 0;
        for(int i = 0; i &lt; grid.length; i ++) {
            for(int j = 0; j &lt; grid[0].length; j ++) {
                if(grid[i][j] == '1') {
                    dfs(grid, i, j);
                    count ++;
                }
            }
        }
        return count;
    }
    
    public void dfs(char[][] grid, int i, int j) {
        if(i &lt; 0 || j &lt; 0 || i &gt;= grid.length || j &gt;= grid[0].length || grid[i][j] != '1' ) 
            return;
        grid[i][j] = '0';
        dfs(grid, i-1, j);
        dfs(grid, i+1, j);
        dfs(grid, i, j-1);
        dfs(grid, i, j+1);
    }

</code></pre>

<h2 id="union-find-solution:7b5dfc6ca8814f1e54ab64455253b7f0">Union-Find solution</h2>

<p>2d version of the above connected components problem.</p>

<pre><code>    public int numIslands(char[][] grid) {
        if(grid == null || grid.length == 0 || grid[0].length == 0)
            return 0;
        int count = 0;
        int m = grid.length, n = grid[0].length;
        int[] root = new int[m * n];
        for(int i = 0; i &lt; m; i ++) {
            for(int j = 0; j &lt; n; j ++) {
                if(grid[i][j] == '1') {
                    count ++;
                }
                int index = i * n + j;
                root[index] = index;
            }
        }
        
        for(int i = 0; i &lt; m; i ++) {
            for(int j = 0; j &lt; n; j ++) {
                if(grid[i][j] == '0') continue;
                int index = i * n + j;
                if(i &gt; 0 &amp;&amp; grid[i-1][j] == '1') {
                    int root1 = find(root, index);
                    int root2 = find(root, index-n);
                    if(root1 != root2) {
                        root[root1] = root2;
                        count --;
                    }
                }
                if(j &gt; 0 &amp;&amp; grid[i][j-1] == '1') {
                    int root1 = find(root, index);
                    int root2 = find(root, index-1);
                    if(root1 != root2) {
                        root[root1] = root2;
                        count --;
                    }
                }
            }
        }
        return count;
    }
    
    public int find(int[] root, int p) {
        if(root[p] == p) 
            return p;
        root[p] = find(root, root[p]);
        return root[p];
    }

</code></pre>

<h1 id="number-of-island-2:7b5dfc6ca8814f1e54ab64455253b7f0">Number of Island 2</h1>

<p>A 2d grid map of m rows and n columns is initially filled with water. We may perform an addLand operation which turns the water at position (row, col) into a land. Given a list of positions to operate, count the number of islands after each addLand operation. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>

<h2 id="example-3:7b5dfc6ca8814f1e54ab64455253b7f0">Example</h2>

<pre><code>Given m = 3, n = 3, positions = [[0,0], [0,1], [1,2], [2,1]].

Initially, the 2d grid grid is filled with water. (Assume 0 represents water and 1 represents land).

Operation #1: addLand(0, 0) turns the water at grid[0][0] into a land.

1 0 0
0 0 0   Number of islands = 1
0 0 0

Operation #2: addLand(0, 1) turns the water at grid[0][1] into a land.

1 1 0
0 0 0   Number of islands = 1
0 0 0

Operation #3: addLand(1, 2) turns the water at grid[1][2] into a land.

1 1 0
0 0 1   Number of islands = 2
0 0 0

Operation #4: addLand(2, 1) turns the water at grid[2][1] into a land.

1 1 0
0 0 1   Number of islands = 3
0 1 0

We return the result as an array: [1, 1, 2, 3]

</code></pre>

<h2 id="solution:7b5dfc6ca8814f1e54ab64455253b7f0">Solution</h2>

<pre><code>    int[][] dirs = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};
    
    public List&lt;Integer&gt; numIslands2(int m, int n, int[][] positions) {
        List&lt;Integer&gt; result = new ArrayList();
        if(positions == null || positions.length == 0)
            return result;
        int[] unionSet = new int[m*n];
        for(int i = 0; i &lt; m*n; i ++)
            unionSet[i] = -1;
            
        int count = 0;
        for(int[] pos: positions) {
            int idx = pos[0] * n + pos[1];
            count ++;
            unionSet[idx] = idx;
            for(int[] dir: dirs) {
                int x = pos[0] + dir[0];
                int y = pos[1] + dir[1];
                if(x &lt; 0 || x == m || y &lt; 0 || y == n || unionSet[x*n+y] == -1)
                    continue;
                int root = find(unionSet, x*n+y);
                if(idx != root) {
                    unionSet[root] = idx;
                    count --;
                }
            }
            result.add(count);
        }
        return result;
    }
    
    public int find(int[] unionSet, int p) {
        if(unionSet[p] == p) return p;
        unionSet[p] = find(unionSet, unionSet[p]);
        return unionSet[p];
    }

</code></pre>

<h1 id="graph-valid-tree:7b5dfc6ca8814f1e54ab64455253b7f0">Graph Valid Tree</h1>

<p>Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.</p>

<p>For example:</p>

<p>Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true.</p>

<p>Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.</p>

<h2 id="solution-1:7b5dfc6ca8814f1e54ab64455253b7f0">Solution</h2>

<p>For the graph to be a tree, it should satisfy 2 conditions:</p>

<ol>
<li>There is no cycle.</li>
<li>Every node is connected in the graph.</li>
</ol>

<p>To check the first condition, we can use dfs or union find. If the first condition is satisfied, we can check the second one using the fact that number of edges in a tree = number of nodes - 1.</p>

<pre><code>    int[] unionSet;
    public boolean validTree(int n, int[][] edges) {
        unionSet = new int[n];
        for(int i = 0; i &lt; n; i ++) {
            unionSet[i] = i;
        }
        for(int[] edge: edges) {
            int x = find(edge[0]);
            int y = find(edge[1]);
            if(x == y)
                return false;
            unionSet[x] = y;
        }
        return edges.length == n - 1;
    }
    
    public int find(int x) {
        if(unionSet[x] == x)
            return x;
        unionSet[x] = find(unionSet[x]);
        return unionSet[x];
    }

</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://yjn93.github.io/dev/ContainsDuplicate/">
        Contains Duplicate
      </a>
    </h1>

    <span class="post-date">Mon, Jan 2, 2017</span>

    

<h1 id="contains-duplicate:a93a8fc10573dbdad791c81926e700b8">Contains Duplicate</h1>

<p>Given an array of integers, find if the array contains any duplicates.</p>

<p>This is the basic problem. The solution is to use a set.</p>

<pre><code>    public boolean containsDuplicate(int[] nums) {
        Set&lt;Integer&gt; set = new HashSet();
        for(int num: nums) {
            if(!set.add(num))
                return true;
        }
        return false;
    }
</code></pre>

<h1 id="contains-duplicate-within-a-window:a93a8fc10573dbdad791c81926e700b8">Contains Duplicate within a window</h1>

<ul>
<li><a href="https://leetcode.com/problems/contains-duplicate-ii/">LeetCode 219</a></li>
</ul>

<p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.</p>

<h2 id="solution:a93a8fc10573dbdad791c81926e700b8">Solution</h2>

<p>We can use a set or a hashmap. We only need to maintain the window size in for loop.</p>

<pre><code>    public boolean containsNearbyDuplicate(int[] nums, int k) {
        Set&lt;Integer&gt; set = new HashSet();
        for(int i = 0; i &lt; nums.length; i ++) {
            if(!set.add(nums[i]))
                return true;
            if(i &gt;= k)
                set.remove(nums[i-k]);
        }
        return false;
    }
</code></pre>

<h1 id="contains-duplicate-in-a-range-within-a-window:a93a8fc10573dbdad791c81926e700b8">Contains Duplicate in a range within a window</h1>

<ul>
<li><a href="https://leetcode.com/problems/contains-duplicate-iii/">LeetCode 220</a></li>
</ul>

<p>Given an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.</p>

<h2 id="treemap-solution:a93a8fc10573dbdad791c81926e700b8">TreeMap solution</h2>

<p>Instead of strict duplicate, there is now a constraint on the range of the values of the elements to be considered duplicates, it reminds us of doing a range check which is implemented in tree data structure and would take O(LogN) if a balanced tree structure is used.</p>

<p>We can use Java TreeSet class. The floor and ceiling method can return the greatest and smallest element within a range in the set.</p>

<pre><code>    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
        TreeSet&lt;Integer&gt; set = new TreeSet();
        for(int i = 0; i &lt; nums.length; i ++) {
            Integer floor = set.floor(nums[i] + t);
            Integer ceiling = set.ceiling(nums[i] - t);
            if((floor != null &amp;&amp; floor &gt;= nums[i]) || (ceiling != null &amp;&amp; ceiling &lt;= nums[i]))
                return true;
            set.add(nums[i]);
            if(i &gt;= k)
                set.remove(nums[i-k]);
        }
        return false;
    }
</code></pre>

<h2 id="bucket-solution:a93a8fc10573dbdad791c81926e700b8">Bucket solution</h2>

<p>This solution is doing constant time complexity.</p>

<p>Notice: to avoid overflow, we need to use Long type.</p>

<p>Another complication is that negative ints are allowed. A simple num / t just shrinks everything towards 0. Therefore, we can just reposition every element to start from Integer.MIN_VALUE.</p>

<pre><code>    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
        if(k &lt; 1 || t &lt; 0) return false;
        Map&lt;Long, Long&gt; map = new HashMap();
        for(int i = 0; i &lt; nums.length; i ++) {
            long newNum = (long)nums[i] - Integer.MIN_VALUE;
            long bucket = newNum/((long)t + 1);
            
            if(map.containsKey(bucket) || 
                map.containsKey(bucket-1) &amp;&amp; newNum - map.get(bucket-1) &lt;= t ||
                map.containsKey(bucket+1) &amp;&amp; map.get(bucket+1) - newNum &lt;= t)
                return true;
            map.put(bucket, newNum);
            if(i &gt;= k) {
                long lastBucket = ((long)nums[i-k] - Integer.MIN_VALUE)/((long)t + 1);
                map.remove(lastBucket);
            }
        }
        return false;
    }
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://yjn93.github.io/dev/Permutations/">
        Permutations
      </a>
    </h1>

    <span class="post-date">Thu, Dec 29, 2016</span>

    

<h1 id="permutation:ae5fadc6fef33d3a20be0c4537ee7524">Permutation</h1>

<ul>
<li><a href="https://leetcode.com/problems/permutations/">LeetCode 46</a></li>
</ul>

<p>Given a collection of distinct numbers, return all possible permutations.</p>

<h2 id="backtracking-by-checking-whether-current-list-contains-an-element:ae5fadc6fef33d3a20be0c4537ee7524">BackTracking by checking whether current list contains an element</h2>

<pre><code>    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        helper(result, new ArrayList(), nums);
        return result;
    }

    public void helper(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; cur, int[] nums) {
        if(cur.size() == nums.length) {
            result.add(new ArrayList(cur));
            return;
        }
        for(int i = 0; i &lt; nums.length; i ++) {
            if(cur.contains(nums[i])) continue;
            cur.add(nums[i]);
            helper(result, cur, nums);
            cur.remove(cur.size()-1);
        }
    }
</code></pre>

<h2 id="backtracking-with-swap:ae5fadc6fef33d3a20be0c4537ee7524">BackTracking with swap</h2>

<p>Try to put every element in current position</p>

<pre><code>    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        helper(result, nums, 0);
        return result;
    }

    public void helper(List&lt;List&lt;Integer&gt;&gt; result, int[] nums, int start) {
        if(start == nums.length) {
            List&lt;Integer&gt; cur = new ArrayList();
            for(int num: nums)
                cur.add(num);
            result.add(cur);
            return;
        }
        for(int i = start; i &lt; nums.length; i ++) {
            swap(nums, i, start);
            helper(result, nums, start+1);
            swap(nums, i, start);
        }
    }
</code></pre>

<h1 id="permutation-2:ae5fadc6fef33d3a20be0c4537ee7524">Permutation 2</h1>

<ul>
<li><a href="https://leetcode.com/problems/permutations-ii/">LeetCode 47</a></li>
</ul>

<p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>

<h2 id="example:ae5fadc6fef33d3a20be0c4537ee7524">Example</h2>

<p>[1,1,2] have the following unique permutations:</p>

<pre><code>[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
</code></pre>

<h2 id="backtracking-to-fulfill-current-list:ae5fadc6fef33d3a20be0c4537ee7524">BackTracking to fulfill current list</h2>

<p>Use an extra boolean array &ldquo; boolean[] used&rdquo; to indicate whether the value is added to list.</p>

<p>Sort the array &ldquo;int[] nums&rdquo; to make sure we can skip the same value.</p>

<p>when a number has the same value with its previous, we can use this number only if his previous is used</p>

<pre><code>    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {
        Arrays.sort(nums);
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList();
        helper(result, new ArrayList(), nums, new boolean[nums.length]);
        return result;
    }

    public void helper(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; cur, int[] nums, boolean[] used) {
        if(cur.size() == nums.length) {
            result.add(new ArrayList(cur));
            return;
        }
        for(int i = 0; i &lt; nums.length; i ++) {
            if(used[i]) continue;
            if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !used[i-1]) continue;
            used[i] = true;
            cur.add(nums[i]);
            helper(result, cur, nums, used);
            cur.remove(cur.size()-1);
            used[i] = false;
        }
    }
</code></pre>

<h1 id="next-permutation:ae5fadc6fef33d3a20be0c4537ee7524">Next Permutation</h1>

<ul>
<li><a href="https://leetcode.com/problems/next-permutation/">LeetCode 31</a></li>
</ul>

<p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>

<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>

<h2 id="solution:ae5fadc6fef33d3a20be0c4537ee7524">Solution</h2>

<pre><code>    public void nextPermutation(int[] nums) {
        int len = nums.length;
        if(len &lt; 2) return;
        int index = len - 1;
        while(index &gt; 0 &amp;&amp; nums[index] &lt;= nums[index-1]) {
                index --;
        }
        if(index == 0) {
            reverse(nums, 0, len-1);
            return;
        }
        index --;
        int i = len-1;
        for(; i &gt; 0; i --){
            if(nums[i] &gt; nums[index])
                break;
        }
        swap(nums, index, i);
        reverse(nums, index+1, len-1);
    }

    public void reverse(int[] nums, int start, int end) {
        if(start &gt;= end)
            return;
        for(int i = start; i &lt;= (end+start)/2; i ++) {
            swap(nums, i, start+end-i);
        }
    }
</code></pre>

<h1 id="permutation-sequence:ae5fadc6fef33d3a20be0c4537ee7524">Permutation Sequence</h1>

<ul>
<li><a href="https://leetcode.com/problems/permutation-sequence/">LeetCode 60</a></li>
</ul>

<p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p>

<p>By listing and labeling all of the permutations in order,
We get the following sequence (ie, for n = 3):</p>

<pre><code>1. &quot;123&quot;
2. &quot;132&quot;
3. &quot;213&quot;
4. &quot;231&quot;
5. &quot;312&quot;
6. &quot;321&quot;
</code></pre>

<p>Given n and k, return the kth permutation sequence.</p>

<h2 id="solution-1:ae5fadc6fef33d3a20be0c4537ee7524">Solution</h2>

<pre><code>    public String getPermutation(int n, int k) {
        int[] factorial = new int[n+1];
        factorial[0] = 1;
        int sum = 1;
        List&lt;Integer&gt; nums = new ArrayList();
        for(int i = 1; i &lt;= n; i ++) {
            sum *= i;
            factorial[i] = sum;
            nums.add(i);
        }
        
        k --;
        StringBuilder sb = new StringBuilder();
        for(int i = 1; i &lt;= n; i ++) {
            int index = k/factorial[n-i];
            sb.append(nums.get(index));
            nums.remove(index);
            k -= index*factorial[n-i];
        }
        return sb.toString();
    }
</code></pre>

<h1 id="palindrome-permutation-ii:ae5fadc6fef33d3a20be0c4537ee7524">Palindrome Permutation II</h1>

<p>Given a string s, return all the palindromic permutations (without duplicates) of it. Return an empty list if no palindromic permutation could be form.</p>

<p>For example:</p>

<p>Given s = &ldquo;aabb&rdquo;, return [&ldquo;abba&rdquo;, &ldquo;baab&rdquo;].</p>

<p>Given s = &ldquo;abc&rdquo;, return [].</p>

<h2 id="solution-2:ae5fadc6fef33d3a20be0c4537ee7524">Solution</h2>

<pre><code>    public List&lt;String&gt; generatePalindromes(String s) {
        List&lt;String&gt; result = new ArrayList();
        if(s == null || s.length() == 0)
            return result;
        Set&lt;Character&gt; set = new HashSet();
        List&lt;Character&gt; sb = new ArrayList();
        for(int i = 0; i &lt; s.length(); i ++) {
            if(!set.add(s.charAt(i))) {
                set.remove(s.charAt(i));
                sb.add(s.charAt(i));
            }
        }
        System.out.println(sb.toString());
        if(set.size() != 0 &amp;&amp; set.size() != 1)
            return result;
        String mid = set.size() == 1 ? set.iterator().next().toString() : &quot;&quot;;
        Collections.sort(sb);
        helper(result, new StringBuilder(), mid, sb, new boolean[sb.size()]);
        return result;        
    }
    
    public void helper(List&lt;String&gt; result, StringBuilder cur, String mid, List&lt;Character&gt; sb, boolean[] used) {
        if(cur.length() == sb.size()) {
            result.add(cur.toString() + mid + cur.reverse().toString());
            // reverse back is very important!!!
            cur.reverse();
            return;
        }
        for(int i = 0; i &lt; sb.size(); i ++) {
            if(used[i]) continue;
            if(i &gt; 0 &amp;&amp; sb.get(i) == sb.get(i-1) &amp;&amp; !used[i-1]) continue;
            cur.append(sb.get(i));
            used[i] = true;
            helper(result, cur, mid, sb, used);
            cur.deleteCharAt(cur.length()-1);
            used[i] = false;
        }
    }

</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://yjn93.github.io/dev/hIndex/">
        hIndex
      </a>
    </h1>

    <span class="post-date">Sat, Dec 24, 2016</span>

    

<h1 id="h-index:37408efcd60dda986ed9231afcc7821f">H Index</h1>

<ul>
<li><a href="https://leetcode.com/problems/h-index/">LeetCode 274</a></li>
</ul>

<p>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher&rsquo;s h-index.</p>

<p>&ldquo;A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.&rdquo;</p>

<p>For example, given citations = [3, 0, 6, 1, 5], which means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, his h-index is 3.</p>

<h2 id="solution:37408efcd60dda986ed9231afcc7821f">Solution</h2>

<p>Use bucket sort. Suppose we have len papers, then h-index cannot exceed len, so we can create len+1 buckets. Each bucket stores the number of papers that have the according citation. Then we iterate from the back to the front of the buckets, whenever the total count exceeds the index of the bucket, meaning that we have the index number of papers that have reference greater than or equal to the index. Which will be our h-index result. The reason to scan from the end of the array is that we are looking for the greatest h-index.</p>

<pre><code>    public int hIndex(int[] citations) {

        int len = citations.length;

        int[] bucket = new int[len+1];

        for(int c: citations) {

            if(c &gt; len) bucket[len] ++;

            else bucket[c] ++;

        }

        int index = 0;

        for(int i = len; i &gt;= 0; i --) {

            index += bucket[i];

            if(index &gt;= i)

                return i;

        }

        return 0;

    }
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://yjn93.github.io/dev/WiggleSequence/">
        Wiggle Subsequence
      </a>
    </h1>

    <span class="post-date">Sat, Dec 24, 2016</span>

    

<h1 id="wiggle-subsequence:5a249ba779613037888e50c3f36770e8">Wiggle Subsequence</h1>

<ul>
<li><a href="https://leetcode.com/problems/wiggle-subsequence/">LeetCode 376</a></li>
</ul>

<p>A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.</p>

<h2 id="example:5a249ba779613037888e50c3f36770e8">Example</h2>

<pre><code>Input: [1,7,4,9,2,5]
Output: 6
The entire sequence is a wiggle sequence.

Input: [1,17,5,10,13,15,10,5,16,8]
Output: 7
There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].

Input: [1,2,3,4,5,6,7,8,9]
Output: 2
</code></pre>

<h2 id="solution:5a249ba779613037888e50c3f36770e8">Solution</h2>

<p>Use two variable up and down to track current maximum length of subsequence that end with up and down respectively.</p>

<pre><code>    public int wiggleMaxLength(int[] nums) {

        if(nums.length &lt; 2) return nums.length;

        int up = 1, down = 1;

        for(int i = 1; i &lt; nums.length; i ++) {

            if(nums[i] &gt; nums[i-1])

                up = down + 1;

            else if (nums[i] &lt; nums[i-1])

                down = up + 1;

        }

        return Math.max(up, down);

    }
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://yjn93.github.io/dev/GuessNumber/">
        GuessNumber
      </a>
    </h1>

    <span class="post-date">Sat, Dec 24, 2016</span>

    

<h1 id="guess-number-higher-or-lower-ii:d06f8d361b54867e9a90313f9c7e4037">Guess Number Higher or Lower II</h1>

<ul>
<li><a href="https://leetcode.com/problems/guess-number-higher-or-lower-ii/">LeetCode</a></li>
</ul>

<p>We are playing the Guess Game. The game is as follows:</p>

<p>I pick a number from 1 to n. You have to guess which number I picked.</p>

<p>Every time you guess wrong, I&rsquo;ll tell you whether the number I picked is higher or lower.</p>

<p>However, when you guess a particular number x, and you guess wrong, you pay $x. You win the game when you guess the number I picked.</p>

<h2 id="example:d06f8d361b54867e9a90313f9c7e4037">Example</h2>

<pre><code>n = 10, I pick 8.

First round:  You guess 5, I tell you that it's higher. You pay $5.
Second round: You guess 7, I tell you that it's higher. You pay $7.
Third round:  You guess 9, I tell you that it's lower. You pay $9.

Game over. 8 is the number I picked.

You end up paying $5 + $7 + $9 = $21.
</code></pre>

<h2 id="solution:d06f8d361b54867e9a90313f9c7e4037">Solution</h2>

<p>For each number x in range[i~j]</p>

<p>we do: result_when_pick_x = x + max{DP([i~x-1]), DP([x+1, j])}</p>

<p>&ndash;&gt; // the max means whenever you choose a number, the feedback is always bad and therefore leads you to a worse branch.</p>

<p>then we get DP([i~j]) = min{xi, &hellip; ,xj}</p>

<p>&ndash;&gt; // this min makes sure that you are minimizing your cost.</p>

<h3 id="recursive-dp:d06f8d361b54867e9a90313f9c7e4037">Recursive DP</h3>

<pre><code>    public int getMoneyAmount(int n) {
        int[][] table = new int[n+1][n+1];
        return dp(table, 1, n);
    }
    
    public int dp(int[][] table, int start, int end) {
        if(start &gt;= end) return 0;
        if(table[start][end] != 0) return table[start][end];
        int result = Integer.MAX_VALUE;
        for(int k = start; k &lt;= end; k ++) {
            result = Math.min(result, k + Math.max(dp(table, start, k-1), dp(table, k+1, end)));
        }
        table[start][end] = result;
        return result;
    }
</code></pre>

<h3 id="bottom-up-dp:d06f8d361b54867e9a90313f9c7e4037">Bottom-up DP</h3>

<p>Fill the table&rsquo;s every column. For each column, it represents the up limit of the range, and we should fill the column from (j-1, j) to (1, j).</p>

<p>Because for example, if i == 1, j == 5, when k = 3, we need table[4][5] be exist.</p>

<p>Also notice the base case is when i + 1 == j, we choose i over j.</p>

<pre><code>    public int getMoneyAmount(int n) {
        int[][] table = new int[n+1][n+1];
        for(int j = 2; j &lt;= n; j ++) {
            for(int i=j-1; i&gt;0; i--) {
                int globalMin = Integer.MAX_VALUE;
                for(int k = i + 1; k &lt; j; k ++) {
                    int localMax = k + Math.max(table[i][k-1], table[k+1][j]);
                    globalMin = Math.min(globalMin, localMax);
                }
                table[i][j] = i + 1 == j ? i : globalMin;
            }
        }
        return table[1][n];
    }

</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://yjn93.github.io/dev/TwoPointers/">
        TwoPointers
      </a>
    </h1>

    <span class="post-date">Fri, Dec 23, 2016</span>

    

<h1 id="container-with-most-water:c2e5aab05fc3611299f5587d4afa2c58">Container With Most Water</h1>

<p>-<a href="https://leetcode.com/problems/container-with-most-water/">LeetCode 11</a></p>

<p>Given n non-negative integers a1, a2, &hellip;, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>

<h2 id="sample:c2e5aab05fc3611299f5587d4afa2c58">Sample</h2>

<p>Reference from LeetCode top solution.</p>

<p>Draw a matrix where the row is the first line, and the column is the second line. For example, say n=6.</p>

<p>In the figures below, x means we don&rsquo;t need to compute the volume for that case: (1) On the diagonal, the two lines are overlapped; (2) The lower left triangle area of the matrix is symmetric to the upper right area.</p>

<p>We start by computing the volume at (1,6), denoted by o. Now if the left line is shorter than the right line, then all the elements left to (1,6) on the first row have smaller volume, so we don&rsquo;t need to compute those cases (crossed by &mdash;).</p>

<pre><code>		  1 2 3 4 5 6
		1 x ------- o
		2 x x
		3 x x x 
		4 x x x x
		5 x x x x x
		6 x x x x x x
</code></pre>

<p>Next we move the left line and compute (2,6). Now if the right line is shorter, all cases below (2,6) are eliminated.</p>

<pre><code>		  1 2 3 4 5 6
		1 x ------- o
		2 x x       o
		3 x x x     |
		4 x x x x   |
		5 x x x x x |
		6 x x x x x x

</code></pre>

<p>And no matter how this o path goes, we end up only need to find the max value on this path, which contains n-1 cases.</p>

<pre><code>		  1 2 3 4 5 6
		1 x ------- o
		2 x x - o o o
		3 x x x o | |
		4 x x x x | |
		5 x x x x x |
		6 x x x x x x
</code></pre>

<h2 id="solution:c2e5aab05fc3611299f5587d4afa2c58">Solution</h2>

<pre><code>    public int maxArea(int[] height) {
        int left = 0, right = height.length-1;
        int max = 0;
        while(left &lt; right) {
            max = Math.max(max, Math.min(height[left], height[right]) * (right - left));
            if(height[left] &lt; height[right])
                left ++;
            else 
                right --;
        }
        return max;
    }
</code></pre>

<h1 id="sort-colors:c2e5aab05fc3611299f5587d4afa2c58">Sort Colors</h1>

<p>-<a href="https://leetcode.com/problems/sort-colors/">LeetCode 75</a></p>

<p>Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>

<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>

<h2 id="solution-1:c2e5aab05fc3611299f5587d4afa2c58">Solution</h2>

<pre><code>    public void sortColors(int[] nums) {
        int left = 0, right = nums.length - 1;
        for(int i = 0; i &lt;= right; i ++) {
            while(nums[i] == 2 &amp;&amp; i &lt; right)
                swap(nums, i, right --);
            while(nums[i] == 0 &amp;&amp; i &gt; left) 
                swap(nums, i, left ++);
        }
    }
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://yjn93.github.io/dev/RotateMatrix/">
        RotateMatrix
      </a>
    </h1>

    <span class="post-date">Thu, Dec 22, 2016</span>

    

<h1 id="rotate-image:18934d05988ea6297312db56d76fae0e">Rotate Image</h1>

<p>You are given an n x n 2D matrix representing an image.</p>

<p>Rotate the image by 90 degrees (clockwise).</p>

<h2 id="trick:18934d05988ea6297312db56d76fae0e">Trick</h2>

<p>I did the rotation in a dummy way. There is a trick:</p>

<p>The idea was firstly transpose the matrix and then flip it symmetrically.</p>

<h2 id="sample:18934d05988ea6297312db56d76fae0e">Sample</h2>

<p>Transpose: swap(matrix[i][j], matrix[j][i])</p>

<pre><code>1  2  3             
4  5  6
7  8  9
</code></pre>

<p>Then flip the matrix horizontally. (swap(matrix[i][j], matrix[i][matrix.length-1-j])</p>

<pre><code>7  4  1
8  5  2
9  6  3

</code></pre>

<h2 id="solution:18934d05988ea6297312db56d76fae0e">Solution</h2>

<pre><code>    public void rotate(int[][] matrix) {
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0)
            return;
        int len = matrix.length;
        for(int i = 0; i &lt; len; i ++) {
            for(int j = i + 1; j &lt; len; j ++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        for(int i = 0; i &lt; len; i ++) {
            for(int j = 0; j &lt; len/2; j ++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[i][len - j - 1];
                matrix[i][len - j - 1] = temp;
            }
        }
    }
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://yjn93.github.io/dev/Knapsack/">
        Knapsack
      </a>
    </h1>

    <span class="post-date">Wed, Dec 21, 2016</span>

    

<h1 id="knapsack-problem:c06120d33a3798cdda1b16554d032ce1">Knapsack problem</h1>

<p>Given weights (wt[i]) and values (val[i]) of n items, put these items in a knapsack of capacity W to get the maximum total value in the knapsack.</p>

<h2 id="basic-dp:c06120d33a3798cdda1b16554d032ce1">Basic dp</h2>

<pre><code>K[i][v]=max{K[i-1][v],K[i-1][v-wt[i]]+val[i]}

int knapSack(int W, int wt[], int val[], int n)
{
   int i, w;
   int K[n+1][W+1];
 
   // Build table K[][] in bottom up manner
   for (i = 0; i &lt;= n; i++)
   {
       for (w = 0; w &lt;= W; w++)
       {
           if (i==0 || w==0)
               K[i][w] = 0;
           else if (wt[i-1] &lt;= w)
                 K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]],  K[i-1][w]);
           else
                 K[i][w] = K[i-1][w];
       }
   }
 
   return K[n][W];
}
</code></pre>

<h2 id="space-optimization:c06120d33a3798cdda1b16554d032ce1">Space optimization</h2>

<p>To make sure in ith loop, K[v-wt[i]] stores previous K[i-1][v-wt[i]], the inner for loop should index in decreasing order.</p>

<pre><code>for i = 1 .. N
	for v = W .. 0
		K[v]=max{K[v],K[v-wt[i]]+val[i]}

</code></pre>

<h1 id="partition-equal-subset-sum:c06120d33a3798cdda1b16554d032ce1">Partition Equal Subset Sum</h1>

<ul>
<li><a href="https://leetcode.com/problems/partition-equal-subset-sum/">LeetCode 416</a></li>
</ul>

<p>Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>

<h2 id="example:c06120d33a3798cdda1b16554d032ce1">Example:</h2>

<pre><code>Input: [1, 5, 11, 5]

Output: true

Explanation: The array can be partitioned as [1, 5, 5] and [11].

Input: [1, 2, 3, 5]

Output: false

Explanation: The array cannot be partitioned into equal sum subsets.

</code></pre>

<h2 id="solution:c06120d33a3798cdda1b16554d032ce1">Solution</h2>

<pre><code>    public boolean canPartition(int[] nums) {
        int sum = 0;
        for(int num: nums) {
            sum += num;
        }
        if(sum % 2 != 0) return false;
        sum /= 2;
        boolean[] dp = new boolean[sum + 1];
        dp[0] = true;
        for(int i = 0; i &lt; nums.length; i ++) {
            for(int j = sum; j &gt;= nums[i]; j --) {
                dp[j] = dp[j] || dp[j - nums[i]];
            }
        }
        
        return dp[sum];
    }
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://yjn93.github.io/dev/QuickSort/">
        QuickSort
      </a>
    </h1>

    <span class="post-date">Wed, Dec 21, 2016</span>

    

<h1 id="kth-largest-element-in-an-array:423f35d8021d43f6473e42ba8f0642fc">Kth Largest Element in an Array</h1>

<ul>
<li><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">LeetCode 215</a></li>
</ul>

<p>Find the kth largest element in an unsorted array.</p>

<h2 id="example:423f35d8021d43f6473e42ba8f0642fc">Example</h2>

<p>Given [3,2,1,5,6,4] and k = 2, return 5.</p>

<h2 id="solution:423f35d8021d43f6473e42ba8f0642fc">Solution</h2>

<p>Quickselect, using quicksort idea. Two implementation of quicksort:</p>

<h3 id="first-implementation-of-partition:423f35d8021d43f6473e42ba8f0642fc">First implementation of partition:</h3>

<pre><code>    public int partition(int[] nums, int start, int end) {
        int pivot = nums[start];
        int left = start, right = end+1;
        while(true) {
            while(left &lt; end &amp;&amp; nums[++ left] &lt; pivot);
            while(start &lt; right &amp;&amp; nums[-- right] &gt; pivot );
            if(left &lt; right) swap(nums, left, right);
            else break;
        }
        swap(nums, start, right);
        return right;
    }
</code></pre>

<h3 id="second-implementation-of-partition:423f35d8021d43f6473e42ba8f0642fc">Second implementation of partition:</h3>

<pre><code>    public int partition(int[] nums, int lo, int hi) {
    	int left = lo, right = hi, pivot = a[hi];
    	while (left &lt; right) {
	      if (a[left++] &gt; pivot) swap(a, --`left, -- right);
    	}
    	swap(a, left, hi);
		return left;
	}
</code></pre>

<h3 id="complete-solution:423f35d8021d43f6473e42ba8f0642fc">Complete Solution</h3>

<pre><code>    public int findKthLargest(int[] nums, int k) {
        k = nums.length - k;
        int lo = 0, hi = nums.length-1;
        while(lo &lt; hi) {
            int split = partition(nums, lo, hi);
            if(split &lt; k) lo = split+1;
            else if(split &gt; k) hi = split - 1;
            else break;
        }
        return nums[k];
    }
    
    public int partition(int[] nums, int start, int end) {
        int pivot = nums[start];
        int left = start, right = end+1;
        while(true) {
            while(left &lt; end &amp;&amp; nums[++ left] &lt; pivot);
            while(start &lt; right &amp;&amp; nums[-- right] &gt; pivot );
            if(left &lt; right) swap(nums, left, right);
            else break;
        }
        swap(nums, start, right);
        return right;
    }
    
    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://yjn93.github.io/dev/Combination_Sum/">
        Combination Sum
      </a>
    </h1>

    <span class="post-date">Sat, Nov 26, 2016</span>

    

<h1 id="combination-sum-3:7a055b9f53e64947361af5747bddcbb5">Combination Sum 3</h1>

<ul>
<li><a href="https://leetcode.com/problems/combination-sum-iii/">LeetCode 216</a></li>
</ul>

<p>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>

<h2 id="example:7a055b9f53e64947361af5747bddcbb5">Example</h2>

<pre><code>k = 3, n = 7
[[1,2,4]]

k = 3, n = 9
[[1,2,6], [1,3,5], [2,3,4]]
</code></pre>

<h2 id="solution:7a055b9f53e64947361af5747bddcbb5">Solution</h2>

<p>BackTracking</p>

<pre><code>    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        helper(result, new ArrayList&lt;Integer&gt;(), k, n, 1);
        return result;
    }
    
    public void helper(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; cur, int k, int n, int start) {
        if(k == 0 &amp;&amp; n == 0) {
            result.add(new ArrayList(cur));
            return;
        }
        if(k == 0 || start &gt; n) return;
        for(int i = start; i &lt;= 9 &amp;&amp; i &lt;= n ; i ++) {
            cur.add(i);
            helper(result, cur, k-1, n-i, i+1);
            cur.remove(cur.size()-1);
        }
    }
</code></pre>

<h1 id="combination-sum-4:7a055b9f53e64947361af5747bddcbb5">Combination Sum 4</h1>

<ul>
<li><a href="https://leetcode.com/problems/combination-sum-iv/">LeetCode 377</a></li>
</ul>

<p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p>

<h2 id="example-1:7a055b9f53e64947361af5747bddcbb5">Example:</h2>

<pre><code>nums = [1, 2, 3]
target = 4

The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

Note that different sequences are counted as different combinations.

Therefore the output is 7.
</code></pre>

<h2 id="solution-1:7a055b9f53e64947361af5747bddcbb5">Solution</h2>

<p>I used recursive solution first, but raised Time Limit Exceeded. This problem actually can be solve in DP because we only need to calculate the possible combinations for a subTarget once.</p>

<pre><code>    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target+1];
        dp[0] = 1;
        for(int i = 1; i &lt;= target; i ++) {
            for(int j = 0; j &lt; nums.length; j ++) {
                if(i - nums[j] &gt;= 0)
                    dp[i] += dp[i-nums[j]];
            }
        }
        return dp[target];
    }
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://yjn93.github.io/dev/Buy_and_Sell_Stocks/">
        Buy and Sell Stocks
      </a>
    </h1>

    <span class="post-date">Fri, Nov 18, 2016</span>

    

<h1 id="one-transaction:bc34b67cdae43a991edbce9949a535fb">One transaction</h1>

<ul>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">LeetCode 121</a></li>
</ul>

<h2 id="solution:bc34b67cdae43a991edbce9949a535fb">Solution</h2>

<h3 id="my-approach:bc34b67cdae43a991edbce9949a535fb">My approach</h3>

<p>Track the min value, update the maxProfit.</p>

<pre><code>    public int maxProfit(int[] prices) {
        int min = Integer.MAX_VALUE;
        int max = 0;
        for(int price: prices) {
            min = Math.min(min, price);
            max = Math.max(max, price-min);
        }
        return max;
    }
</code></pre>

<h3 id="kadane-s-algorithm-solution:bc34b67cdae43a991edbce9949a535fb">Kadane&rsquo;s Algorithm Solution</h3>

<p>Kadane&rsquo;s Algorithm is used to solve Maximum Subarray problem
Here, the logic is to calculate the difference (maxCur += prices[i] - prices[i-1]) of the original array, and find a contiguous subarray giving maximum profit. If the difference falls below 0, reset it to zero.</p>

<pre><code>    public int maxProfit(int[] prices) {
        int curMax = 0;
        int max = 0;
        for(int i = 1; i &lt; prices.length; i ++) {
            curMax = Math.max(0, curMax+prices[i]-prices[i-1]);
            max = Math.max(max, curMax);
        }
        return max;
    }
</code></pre>

<h2 id="maximum-subarray-problem:bc34b67cdae43a991edbce9949a535fb">Maximum Subarray Problem</h2>

<ul>
<li><a href="https://leetcode.com/problems/maximum-subarray/">LeetCode 53</a></li>
</ul>

<h3 id="example:bc34b67cdae43a991edbce9949a535fb">Example</h3>

<p>given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum = 6.</p>

<h3 id="solution-1:bc34b67cdae43a991edbce9949a535fb">Solution</h3>

<p>Using Kadane&rsquo;s algorithm, which consists of a scan through the array values, computing at each position the maximum (positive sum) subarray ending at that position. This subarray is either empty (in which case its sum is zero) or consists of one more element than the maximum subarray ending at the previous position.</p>

<pre><code>    public int maxSubArray(int[] nums) {
        int max = Integer.MIN_VALUE;
        int leftMax = 0;
        for(int num: nums) {
            max = Math.max(max, leftMax+num);
            leftMax = Math.max(0, leftMax+num);
        }
        return max;
    }
</code></pre>

<h3 id="notice:bc34b67cdae43a991edbce9949a535fb">Notice</h3>

<p>The corner case: all elements are negative.</p>

<h1 id="many-transactions:bc34b67cdae43a991edbce9949a535fb">Many transactions</h1>

<ul>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">LeetCode 122</a></li>
</ul>

<h2 id="peak-and-valley-approach:bc34b67cdae43a991edbce9949a535fb">Peak and Valley approach</h2>

<pre><code>    public int maxProfit(int[] prices) {
        int result = 0;
        int idx = 0;
        while(idx &lt; prices.length-1) {
            while(idx+1 &lt; prices.length &amp;&amp; prices[idx+1] &lt;= prices[idx])
                idx ++;
            int low = prices[idx];
            while(idx+1 &lt; prices.length &amp;&amp; prices[idx+1] &gt;= prices[idx])
                idx ++;
            result += prices[idx]-low;
            idx ++;
        }
        return result;
    }
</code></pre>

<h2 id="simple-one-pass:bc34b67cdae43a991edbce9949a535fb">Simple one pass</h2>

<p>we can directly keep on adding the difference between the consecutive numbers of the array if the second number is larger than the first one, and at the total sum we obtain will be the maximum profit.</p>

<pre><code>    public int maxProfit(int[] prices) {
        int max = 0;
        for(int i = 1; i &lt; prices.length; i ++) {
            if(prices[i] &gt; prices[i-1])
                max += prices[i]-prices[i-1];
        }
        return max;
    }
</code></pre>

<h1 id="multiple-transactions-with-cooldown:bc34b67cdae43a991edbce9949a535fb">Multiple transactions with cooldown</h1>

<ul>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">LeetCode 309</a></li>
</ul>

<h2 id="example-1:bc34b67cdae43a991edbce9949a535fb">Example</h2>

<pre><code>prices = [1, 2, 3, 0, 2]
maxProfit = 3
transactions = [buy, sell, cooldown, buy, sell]
</code></pre>

<h2 id="solution-2:bc34b67cdae43a991edbce9949a535fb">Solution</h2>

<p>Dynamic programming: tracking the maxProfit for ending with sell and buy</p>

<pre><code>buy[i] = max(sell[i-2]-price, buy[i-1])
sell[i] = max(buy[i-1]+price, sell[i-1])
</code></pre>

<p>Can reduce the space:</p>

<pre><code>preBuy = curBuy;
curBuy = max(preSell-num, preBuy);
preSell = curSell;
curSell = max(preBuy+num, preSell);
</code></pre>

<p>Java code</p>

<pre><code>    public int maxProfit(int[] prices) {
        int preSell = 0, curSell = 0;
		int curBuy = Integer.MIN_VALUE, preBuy;
        for(int price: prices) {
            preBuy = curBuy;
            curBuy = Math.max(preSell - price, preBuy);
            preSell = curSell;
            curSell = Math.max(preBuy + price, preSell);
        }
        return curSell;
    }

</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://yjn93.github.io/dev/Bit-Manipulation/">
        Bit Manipulation
      </a>
    </h1>

    <span class="post-date">Sun, Nov 13, 2016</span>

    

<h1 id="clever-tricks:3344d83625fb333615fef7b8a8bdad05">Clever Tricks</h1>

<h3 id="get-the-rightmost-set-bit:3344d83625fb333615fef7b8a8bdad05">Get the rightmost set bit</h3>

<pre><code>	num &amp;= -num;
</code></pre>

<h3 id="set-the-rightmost-1-to-0:3344d83625fb333615fef7b8a8bdad05">Set the rightmost 1 to 0</h3>

<pre><code>	num &amp;= (num-1)
</code></pre>

<h3 id="facts:3344d83625fb333615fef7b8a8bdad05">Facts</h3>

<ul>
<li>~(num-1) == -num</li>
</ul>

<h1 id="single-number-iii:3344d83625fb333615fef7b8a8bdad05">Single Number III</h1>

<ul>
<li><a href="https://leetcode.com/problems/single-number-iii/">LeetCode 260</a></li>
</ul>

<p>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p>

<h2 id="example:3344d83625fb333615fef7b8a8bdad05">Example:</h2>

<p>Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].</p>

<h2 id="solution:3344d83625fb333615fef7b8a8bdad05">Solution</h2>

<p>In the first pass of for loop, we XOR all elements in the array, and get the XOR of the two numbers we need to find.</p>

<p>The second pass is hard to come up with, we use the trick in the first session to get the rightmost set bit of the XOR of the two target number. We can divide all elements in two groups, and the target two numbers will fall into different groups.</p>

<pre><code>    public int[] singleNumber(int[] nums) {
        int diff = 0;
        for(int num: nums) {
            diff ^= num;
        }
        diff &amp;= -diff;
        int[] result = {0,0};
        for(int num: nums) {
            if((num &amp; diff) == 0)
                result[0] ^= num;
            else
                result[1] ^= num;
        }
        return result;
    }
</code></pre>

<h1 id="single-number-ii:3344d83625fb333615fef7b8a8bdad05">Single Number II</h1>

<ul>
<li><a href="https://leetcode.com/problems/single-number-ii/">LeetCode 137</a></li>
</ul>

<p>Given an array of integers, every element appears three times except for one. Find that single one.</p>

<h2 id="solution-1:3344d83625fb333615fef7b8a8bdad05">Solution</h2>

<pre><code>    public int singleNumber(int[] nums) {
        int ones = 0, twos = 0;
        for(int num: nums) {
            ones = (ones ^ num) &amp; ~twos;
            twos = (twos ^ num) &amp; ~ones;
        }
        return ones;
    }
</code></pre>

<h1 id="missing-number:3344d83625fb333615fef7b8a8bdad05">Missing Number</h1>

<ul>
<li><a href="https://leetcode.com/problems/missing-number/">LeetCode 268</a></li>
</ul>

<p>Given an array containing n distinct numbers taken from 0, 1, 2, &hellip;, n, find the one that is missing from the array.</p>

<h2 id="example-1:3344d83625fb333615fef7b8a8bdad05">Example</h2>

<p>Given nums = [0, 1, 3] return 2.</p>

<h2 id="solution-2:3344d83625fb333615fef7b8a8bdad05">Solution</h2>

<pre><code>    public int missingNumber(int[] nums) {
        int result = nums.length;
        for(int i = 0; i &lt; nums.length; i ++) {
            result ^= i;
            result ^= nums[i];
        }
        return result;
    }

</code></pre>

<h1 id="integer-replacement:3344d83625fb333615fef7b8a8bdad05">Integer Replacement</h1>

<ul>
<li><a href="https://leetcode.com/problems/integer-replacement/">LeetCode 397</a></li>
</ul>

<p>Given a positive integer n and you can do operations as follow:</p>

<p>If n is even, replace n with n/2.</p>

<p>If n is odd, you can replace n with either n + 1 or n - 1.</p>

<p>What is the minimum number of replacements needed for n to become 1?</p>

<h2 id="example-2:3344d83625fb333615fef7b8a8bdad05">Example</h2>

<p>Input: 8</p>

<p>Output: 3</p>

<p>Explanation: 8 -&gt; 4 -&gt; 2 -&gt; 1</p>

<p>Input: 7</p>

<p>Output: 4</p>

<p>Explanation: 7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1 or 7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1</p>

<h2 id="solution-3:3344d83625fb333615fef7b8a8bdad05">Solution</h2>

<p>Recursion will cause StackOverFlow. There are two ways for this problem. One uses iteration, one use bit manipulation.</p>

<h3 id="iteration:3344d83625fb333615fef7b8a8bdad05">Iteration</h3>

<p>When n is odd it can be written into the form n = 2k+1 (k is a non-negative integer.). That is, n+1 = 2k+2 and n-1 = 2k. Then, (n+1)/2 = k+1 and (n-1)/2 = k. So one of (n+1)/2 and (n-1)/2 is even, the other is odd. And the &ldquo;best&rdquo; case of this problem is to divide as much as possible. Because of that, always pick n+1 or n-1 based on if it can be divided by 4. The only special case of that is when n=3 you would like to pick n-1 rather than n+1.</p>

<pre><code>    public int integerReplacement(int n) {
        if(n == Integer.MAX_VALUE) return 32;
        int count = 0;
        while(n != 1) {
            if(n % 2 == 0) {
                n /= 2;
            } else {
                if((n + 1) % 4 == 0 &amp;&amp; n != 3)
                    n += 1;
                else
                    n -= 1;
            }
            count ++;
        }
        return count;
    }
</code></pre>

<h3 id="bit-manipulation:3344d83625fb333615fef7b8a8bdad05">Bit Manipulation</h3>

<p>We can use the same idea to do bit manipulation. When n is odd, we only need to check the last two bits of n. If the second least significant bit is 1, then increase n by 1, unless n is 3.</p>

<pre><code>    public int integerReplacement(int n) {
        int count = 0;
        while(n != 1) {
            if(n % 2 == 0)
                n &gt;&gt;&gt;= 1;
            else if(n == 3 || ((n &gt;&gt;&gt; 1) &amp; 1) == 0)
                n --;
            else 
                n ++;
            count ++;
        }
        return count;
    }
</code></pre>

<h1 id="subsets:3344d83625fb333615fef7b8a8bdad05">Subsets</h1>

<p>Given a set of distinct integers, nums, return all possible subsets.</p>

<p>Note: The solution set must not contain duplicate subsets.</p>

<p>For example,
If nums = [1,2,3], a solution is:</p>

<pre><code>[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]

</code></pre>

<h2 id="backtracking-solution:3344d83625fb333615fef7b8a8bdad05">BackTracking Solution</h2>

<pre><code>    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        backTracking(result, new ArrayList&lt;Integer&gt;(), nums, 0);
        return result;
    }
    
    public void backTracking(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; subset, int[] nums, int start) {
        result.add(new ArrayList&lt;Integer&gt;(subset));
        for(int i = start; i &lt; nums.length; i ++) {
            subset.add(nums[i]);
            backTracking(result, subset, nums, i+1);
            subset.remove(subset.size()-1);
        }
    }

</code></pre>

<h2 id="bit-manipulation-solution:3344d83625fb333615fef7b8a8bdad05">Bit Manipulation Solution</h2>

<p>We can take or not take an element, so we can represent one subset as a unique state sequence.</p>

<pre><code>    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        int total = 1 &lt;&lt; nums.length;
        for(int i = 0; i &lt; total; i ++) {
            List&lt;Integer&gt; cur = new ArrayList();
            for(int j = 0; j &lt; nums.length; j ++) {
                if(((1 &lt;&lt; j) &amp; i) != 0)
                    cur.add(nums[j]);
            }
            result.add(cur);
        }
        return result;
    }

</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://yjn93.github.io/dev/Counting-Bits/">
        Counting Bits
      </a>
    </h1>

    <span class="post-date">Sat, Nov 12, 2016</span>

    

<h1 id="problem-description:022354bb3fdd3cdde4f44cb9f57b56b0">Problem description</h1>

<ul>
<li><a href="https://leetcode.com/problems/counting-bits/">LeetCode 338</a></li>
</ul>

<p>Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1&rsquo;s in their binary representation and return them as an array.</p>

<h2 id="example:022354bb3fdd3cdde4f44cb9f57b56b0">Example:</h2>

<p>For num = 5 you should return [0,1,1,2,1,2]</p>

<h2 id="my-dp-solution:022354bb3fdd3cdde4f44cb9f57b56b0">My DP Solution</h2>

<p>This problem can be solved by dynamic programming because the count of bits follow certains rules as the number grows:</p>

<pre><code>		0	0
		1	1
		2	10
		3	11
</code></pre>

<p>The number 2 is adding another bit 1 in front of number 0; the number 3 is adding another bit 1 at the beginning of number 1. So my solution is to track the previous size of numbers that can be represented by a fix number of bits. For example, we have 0, 1 initially, the size is 2. Then for 3, 4, we apply the formula:</p>

<pre><code>dp[i] = dp[i-size] + 1
dp[2] = dp[2 - 2] + 1 = dp[0] + 1 
dp[3] = dp[3 - 2] + 1 = dp[1] + 1

</code></pre>

<p>Then, for number 4, we need more bits to represent it, so the previous size is updated to 4, and dp[4], dp[5], dp[6], dp[7] can be calculated by dp[0], dp[1], dp[2], dp[3]. My code is as following:</p>

<pre><code>    public int[] countBits(int num) {
        if(num == 0) return new int[]{0};
        int[] dp = new int[num+1];
        dp[0] = 0;
        dp[1] = 1;
        int size = 2;
        for(int i = 2; i &lt;= num; i ++) {
            if(i - size == size)
                size = i;
            dp[i] = 1 + dp[i-size];
        }
        return dp;
    }

</code></pre>

<h2 id="another-dp-solution-combining-bit-manipulation:022354bb3fdd3cdde4f44cb9f57b56b0">Another DP solution combining Bit Manipulation</h2>

<p>Instead of adding the bit 1 infront of the previous cycle, this brilliant solution think it as deleting the last bit to obtain the number of bits without last bit, then add another counting for last bit if the last bit is 1.</p>

<p>4-line:</p>

<pre><code>    public int[] countBits(int num) {
        int[] dp = new int[num+1];
        for(int i = 1; i &lt;= num; i ++) 
            dp[i] = dp[i&gt;&gt;1] + (i&amp;1);
        return dp;
    }
</code></pre>

<p>Notice the priority for &amp; operator is lower than +, so we need to use () for (i&amp;1).</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://yjn93.github.io/blog/%E6%9C%80%E5%A5%BD%E7%9A%84%E8%87%AA%E5%B7%B1/">
        最好的自己
      </a>
    </h1>

    <span class="post-date">Sat, Oct 8, 2016</span>

    <p>最近觉得自己格外迷茫，人生一直按部就班的过，考高中，考大学，申请国外研究生，可却完全不知道自己喜欢什么，想要什么。忽然有一天需要自己承担责任，自己做决定，就纠结的要死，完全想象不到一年后的自己会在哪里做什么。</p>

<p>我害怕把日子过成黑白片；也害怕找不到自己想要的彩色是什么。</p>

<p>昨天知乎了两件事，一个是安稳，一个是快乐。</p>

<p>其实每个人都追求安稳，只不过稳定的层次不一样，有人在一楼安稳下来了，觉得这么过就很好，而有的人在二楼安稳却还想要努力一把去三楼安稳。</p>

<p>“知道了生活的现实，却依然愿意走出「稳定」的小绿洲，踏上那荆棘满地却又风景如画的路途，我觉得这才是真正的勇敢和乐观&rdquo; ——知乎</p>

<p>关于快乐，我曾经跟室友讨论过，她想要什么样的生活，她说想要快乐的生活。我额子也老说，还是觉得活着很好，很快乐。我也很想要热爱生活，可是不知道为什么会那么烦，不知道要怎么快乐。</p>

<p>又看了知乎，有这样一个答案：</p>

<p>想太多“意义”，想太多“快不快乐”，杀死了我们的“快乐”。
“理智”杀死了我们的快乐。 我们想了太多，算计太多，失掉了快乐需要的感性。嗯，不去想它怎样？就着手做好自己手头的事情。</p>

<p>是啊，本来没有什么烦恼，现在想太多没有定数的事情给自己徒增烦恼。以前觉得别人说&rdquo;不想长大&rdquo;都是矫情，人生好不容易过到了现在，我可不想回到以前。而最近真的有点不想长大了，害怕未来也后悔过去有些事没有做，或许这是真的不再年少了吧。</p>

<p>今天看了《最好的我们》, 作者八月长安是个知道自己想要什么的人。作品塑造的也是比我优秀还比我努力的人。我想要一个这样纯粹的爱情，也怀念自己曾经拼搏过的时光。</p>

<p>我从来都没有达到自己心目中最好的自己，希望自己能像准备高考，准备GRE时一样，不畏艰难再努力一把，少想多做，相信也能自然而然的获得快乐。</p>

<p>最近练瑜伽老师是个平静的老奶奶，她教我们冥想“You have nowhere to go and nothing to do”。乱想并不能改变去向与未来，还是踏踏实实做好眼前的事吧。</p>

<p>先定一个小小的目标，比如瘦个5斤~</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://yjn93.github.io/dev/cheat-sheet/">
        Cheat sheet
      </a>
    </h1>

    <span class="post-date">Wed, Jul 6, 2016</span>

    

<h2 id="vim-reference:973531de47c0d1a1c68391da818ea75f">Vim Reference</h2>

<ul>
<li><a href="https://www.fprintf.net/vimCheatSheet.html">Vim Cheat Sheet</a></li>
<li><a href="http://www.radford.edu/~mhtay/CPSC120/VIM_Editor_Commands.htm">Vim Editer Command</a></li>
</ul>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://yjn93.github.io/about/">
        About
      </a>
    </h1>

    <span class="post-date">Tue, Jul 5, 2016</span>

    

<h2 id="timeline:6083a88ee3411b0d17ce02d738f69d47">Timeline</h2>

<ul>
<li>2011 Undergrads.CS@Nanjing University</li>
<li>2015 Master.CS@McGill University</li>
<li>2016 Summer Intern@Morgan Stanley</li>
</ul>

<h2 id="principles:6083a88ee3411b0d17ce02d738f69d47">Principles</h2>

<ul>
<li>Keep everything (code and life) simple and clear</li>
<li>Caring and considerate, love and peace</li>
<li>Step out of the comfort zone</li>
</ul>

  </div>
  
</div>
</div>

  </body>
</html>
