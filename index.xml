<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>木秀于南</title>
    <link>http://yjn93.github.io/</link>
    <description>Recent content on 木秀于南</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© 2016 Jianan Yue. All right reserved.</copyright>
    <lastBuildDate>Thu, 22 Dec 2016 13:15:37 -0500</lastBuildDate>
    <atom:link href="http://yjn93.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>RotateMatrix</title>
      <link>http://yjn93.github.io/dev/RotateMatrix/</link>
      <pubDate>Thu, 22 Dec 2016 13:15:37 -0500</pubDate>
      
      <guid>http://yjn93.github.io/dev/RotateMatrix/</guid>
      <description>

&lt;h1 id=&#34;rotate-image:18934d05988ea6297312db56d76fae0e&#34;&gt;Rotate Image&lt;/h1&gt;

&lt;p&gt;You are given an n x n 2D matrix representing an image.&lt;/p&gt;

&lt;p&gt;Rotate the image by 90 degrees (clockwise).&lt;/p&gt;

&lt;h2 id=&#34;trick:18934d05988ea6297312db56d76fae0e&#34;&gt;Trick&lt;/h2&gt;

&lt;p&gt;I did the rotation in a dummy way. There is a trick:&lt;/p&gt;

&lt;p&gt;The idea was firstly transpose the matrix and then flip it symmetrically.&lt;/p&gt;

&lt;h2 id=&#34;sample:18934d05988ea6297312db56d76fae0e&#34;&gt;Sample&lt;/h2&gt;

&lt;p&gt;Transpose: swap(matrix[i][j], matrix[j][i])&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1  2  3             
4  5  6
7  8  9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then flip the matrix horizontally. (swap(matrix[i][j], matrix[i][matrix.length-1-j])&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;7  4  1
8  5  2
9  6  3

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution:18934d05988ea6297312db56d76fae0e&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public void rotate(int[][] matrix) {
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0)
            return;
        int len = matrix.length;
        for(int i = 0; i &amp;lt; len; i ++) {
            for(int j = i + 1; j &amp;lt; len; j ++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        for(int i = 0; i &amp;lt; len; i ++) {
            for(int j = 0; j &amp;lt; len/2; j ++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[i][len - j - 1];
                matrix[i][len - j - 1] = temp;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Knapsack</title>
      <link>http://yjn93.github.io/dev/Knapsack/</link>
      <pubDate>Wed, 21 Dec 2016 12:19:33 -0500</pubDate>
      
      <guid>http://yjn93.github.io/dev/Knapsack/</guid>
      <description>

&lt;h1 id=&#34;knapsack-problem:c06120d33a3798cdda1b16554d032ce1&#34;&gt;Knapsack problem&lt;/h1&gt;

&lt;p&gt;Given weights (wt[i]) and values (val[i]) of n items, put these items in a knapsack of capacity W to get the maximum total value in the knapsack.&lt;/p&gt;

&lt;h2 id=&#34;basic-dp:c06120d33a3798cdda1b16554d032ce1&#34;&gt;Basic dp&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;K[i][v]=max{K[i-1][v],K[i-1][v-wt[i]]+val[i]}

int knapSack(int W, int wt[], int val[], int n)
{
   int i, w;
   int K[n+1][W+1];
 
   // Build table K[][] in bottom up manner
   for (i = 0; i &amp;lt;= n; i++)
   {
       for (w = 0; w &amp;lt;= W; w++)
       {
           if (i==0 || w==0)
               K[i][w] = 0;
           else if (wt[i-1] &amp;lt;= w)
                 K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]],  K[i-1][w]);
           else
                 K[i][w] = K[i-1][w];
       }
   }
 
   return K[n][W];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;space-optimization:c06120d33a3798cdda1b16554d032ce1&#34;&gt;Space optimization&lt;/h2&gt;

&lt;p&gt;To make sure in ith loop, K[v-wt[i]] stores previous K[i-1][v-wt[i]], the inner for loop should index in decreasing order.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i = 1 .. N
	for v = W .. 0
		K[v]=max{K[v],K[v-wt[i]]+val[i]}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;partition-equal-subset-sum:c06120d33a3798cdda1b16554d032ce1&#34;&gt;Partition Equal Subset Sum&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/partition-equal-subset-sum/&#34;&gt;LeetCode 416&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.&lt;/p&gt;

&lt;h2 id=&#34;example:c06120d33a3798cdda1b16554d032ce1&#34;&gt;Example:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Input: [1, 5, 11, 5]

Output: true

Explanation: The array can be partitioned as [1, 5, 5] and [11].

Input: [1, 2, 3, 5]

Output: false

Explanation: The array cannot be partitioned into equal sum subsets.

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution:c06120d33a3798cdda1b16554d032ce1&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public boolean canPartition(int[] nums) {
        int sum = 0;
        for(int num: nums) {
            sum += num;
        }
        if(sum % 2 != 0) return false;
        sum /= 2;
        boolean[] dp = new boolean[sum + 1];
        dp[0] = true;
        for(int i = 0; i &amp;lt; nums.length; i ++) {
            for(int j = sum; j &amp;gt;= nums[i]; j --) {
                dp[j] = dp[j] || dp[j - nums[i]];
            }
        }
        
        return dp[sum];
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>QuickSort</title>
      <link>http://yjn93.github.io/dev/QuickSort/</link>
      <pubDate>Wed, 21 Dec 2016 09:59:54 -0500</pubDate>
      
      <guid>http://yjn93.github.io/dev/QuickSort/</guid>
      <description>

&lt;h1 id=&#34;kth-largest-element-in-an-array:423f35d8021d43f6473e42ba8f0642fc&#34;&gt;Kth Largest Element in an Array&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/kth-largest-element-in-an-array/&#34;&gt;LeetCode 215&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Find the kth largest element in an unsorted array.&lt;/p&gt;

&lt;h2 id=&#34;example:423f35d8021d43f6473e42ba8f0642fc&#34;&gt;Example&lt;/h2&gt;

&lt;p&gt;Given [3,2,1,5,6,4] and k = 2, return 5.&lt;/p&gt;

&lt;h2 id=&#34;solution:423f35d8021d43f6473e42ba8f0642fc&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;Quickselect, using quicksort idea. Two implementation of quicksort:&lt;/p&gt;

&lt;h3 id=&#34;first-implementation-of-partition:423f35d8021d43f6473e42ba8f0642fc&#34;&gt;First implementation of partition:&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    public int partition(int[] nums, int start, int end) {
        int pivot = nums[start];
        int left = start, right = end+1;
        while(true) {
            while(left &amp;lt; end &amp;amp;&amp;amp; nums[++ left] &amp;lt; pivot);
            while(start &amp;lt; right &amp;amp;&amp;amp; nums[-- right] &amp;gt; pivot );
            if(left &amp;lt; right) swap(nums, left, right);
            else break;
        }
        swap(nums, start, right);
        return right;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;second-implementation-of-partition:423f35d8021d43f6473e42ba8f0642fc&#34;&gt;Second implementation of partition:&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    public int partition(int[] nums, int lo, int hi) {
    	int left = lo, right = hi, pivot = a[hi];
    	while (left &amp;lt; right) {
	      if (a[left++] &amp;gt; pivot) swap(a, --`left, -- right);
    	}
    	swap(a, left, hi);
		return left;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;complete-solution:423f35d8021d43f6473e42ba8f0642fc&#34;&gt;Complete Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    public int findKthLargest(int[] nums, int k) {
        k = nums.length - k;
        int lo = 0, hi = nums.length-1;
        while(lo &amp;lt; hi) {
            int split = partition(nums, lo, hi);
            if(split &amp;lt; k) lo = split+1;
            else if(split &amp;gt; k) hi = split - 1;
            else break;
        }
        return nums[k];
    }
    
    public int partition(int[] nums, int start, int end) {
        int pivot = nums[start];
        int left = start, right = end+1;
        while(true) {
            while(left &amp;lt; end &amp;amp;&amp;amp; nums[++ left] &amp;lt; pivot);
            while(start &amp;lt; right &amp;amp;&amp;amp; nums[-- right] &amp;gt; pivot );
            if(left &amp;lt; right) swap(nums, left, right);
            else break;
        }
        swap(nums, start, right);
        return right;
    }
    
    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Combination Sum</title>
      <link>http://yjn93.github.io/dev/Combination_Sum/</link>
      <pubDate>Sat, 26 Nov 2016 10:30:22 -0500</pubDate>
      
      <guid>http://yjn93.github.io/dev/Combination_Sum/</guid>
      <description>

&lt;h1 id=&#34;combination-sum-3:7a055b9f53e64947361af5747bddcbb5&#34;&gt;Combination Sum 3&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/combination-sum-iii/&#34;&gt;LeetCode 216&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.&lt;/p&gt;

&lt;h2 id=&#34;example:7a055b9f53e64947361af5747bddcbb5&#34;&gt;Example&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;k = 3, n = 7
[[1,2,4]]

k = 3, n = 9
[[1,2,6], [1,3,5], [2,3,4]]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution:7a055b9f53e64947361af5747bddcbb5&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;BackTracking&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum3(int k, int n) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
        helper(result, new ArrayList&amp;lt;Integer&amp;gt;(), k, n, 1);
        return result;
    }
    
    public void helper(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result, List&amp;lt;Integer&amp;gt; cur, int k, int n, int start) {
        if(k == 0 &amp;amp;&amp;amp; n == 0) {
            result.add(new ArrayList(cur));
            return;
        }
        if(k == 0 || start &amp;gt; n) return;
        for(int i = start; i &amp;lt;= 9 &amp;amp;&amp;amp; i &amp;lt;= n ; i ++) {
            cur.add(i);
            helper(result, cur, k-1, n-i, i+1);
            cur.remove(cur.size()-1);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;combination-sum-4:7a055b9f53e64947361af5747bddcbb5&#34;&gt;Combination Sum 4&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/combination-sum-iv/&#34;&gt;LeetCode 377&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.&lt;/p&gt;

&lt;h2 id=&#34;example-1:7a055b9f53e64947361af5747bddcbb5&#34;&gt;Example:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;nums = [1, 2, 3]
target = 4

The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

Note that different sequences are counted as different combinations.

Therefore the output is 7.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-1:7a055b9f53e64947361af5747bddcbb5&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;I used recursive solution first, but raised Time Limit Exceeded. This problem actually can be solve in DP because we only need to calculate the possible combinations for a subTarget once.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target+1];
        dp[0] = 1;
        for(int i = 1; i &amp;lt;= target; i ++) {
            for(int j = 0; j &amp;lt; nums.length; j ++) {
                if(i - nums[j] &amp;gt;= 0)
                    dp[i] += dp[i-nums[j]];
            }
        }
        return dp[target];
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Buy and Sell Stocks</title>
      <link>http://yjn93.github.io/dev/Buy_and_Sell_Stocks/</link>
      <pubDate>Fri, 18 Nov 2016 09:54:11 -0500</pubDate>
      
      <guid>http://yjn93.github.io/dev/Buy_and_Sell_Stocks/</guid>
      <description>

&lt;h1 id=&#34;one-transaction:bc34b67cdae43a991edbce9949a535fb&#34;&gt;One transaction&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/best-time-to-buy-and-sell-stock/&#34;&gt;LeetCode 121&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:bc34b67cdae43a991edbce9949a535fb&#34;&gt;Solution&lt;/h2&gt;

&lt;h3 id=&#34;my-approach:bc34b67cdae43a991edbce9949a535fb&#34;&gt;My approach&lt;/h3&gt;

&lt;p&gt;Track the min value, update the maxProfit.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int maxProfit(int[] prices) {
        int min = Integer.MAX_VALUE;
        int max = 0;
        for(int price: prices) {
            min = Math.min(min, price);
            max = Math.max(max, price-min);
        }
        return max;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;kadane-s-algorithm-solution:bc34b67cdae43a991edbce9949a535fb&#34;&gt;Kadane&amp;rsquo;s Algorithm Solution&lt;/h3&gt;

&lt;p&gt;Kadane&amp;rsquo;s Algorithm is used to solve Maximum Subarray problem
Here, the logic is to calculate the difference (maxCur += prices[i] - prices[i-1]) of the original array, and find a contiguous subarray giving maximum profit. If the difference falls below 0, reset it to zero.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int maxProfit(int[] prices) {
        int curMax = 0;
        int max = 0;
        for(int i = 1; i &amp;lt; prices.length; i ++) {
            curMax = Math.max(0, curMax+prices[i]-prices[i-1]);
            max = Math.max(max, curMax);
        }
        return max;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;maximum-subarray-problem:bc34b67cdae43a991edbce9949a535fb&#34;&gt;Maximum Subarray Problem&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/maximum-subarray/&#34;&gt;LeetCode 53&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;example:bc34b67cdae43a991edbce9949a535fb&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum = 6.&lt;/p&gt;

&lt;h3 id=&#34;solution-1:bc34b67cdae43a991edbce9949a535fb&#34;&gt;Solution&lt;/h3&gt;

&lt;p&gt;Using Kadane&amp;rsquo;s algorithm, which consists of a scan through the array values, computing at each position the maximum (positive sum) subarray ending at that position. This subarray is either empty (in which case its sum is zero) or consists of one more element than the maximum subarray ending at the previous position.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int maxSubArray(int[] nums) {
        int max = Integer.MIN_VALUE;
        int leftMax = 0;
        for(int num: nums) {
            max = Math.max(max, leftMax+num);
            leftMax = Math.max(0, leftMax+num);
        }
        return max;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;notice:bc34b67cdae43a991edbce9949a535fb&#34;&gt;Notice&lt;/h3&gt;

&lt;p&gt;The corner case: all elements are negative.&lt;/p&gt;

&lt;h1 id=&#34;many-transactions:bc34b67cdae43a991edbce9949a535fb&#34;&gt;Many transactions&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/&#34;&gt;LeetCode 122&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;peak-and-valley-approach:bc34b67cdae43a991edbce9949a535fb&#34;&gt;Peak and Valley approach&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public int maxProfit(int[] prices) {
        int result = 0;
        int idx = 0;
        while(idx &amp;lt; prices.length-1) {
            while(idx+1 &amp;lt; prices.length &amp;amp;&amp;amp; prices[idx+1] &amp;lt;= prices[idx])
                idx ++;
            int low = prices[idx];
            while(idx+1 &amp;lt; prices.length &amp;amp;&amp;amp; prices[idx+1] &amp;gt;= prices[idx])
                idx ++;
            result += prices[idx]-low;
            idx ++;
        }
        return result;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;simple-one-pass:bc34b67cdae43a991edbce9949a535fb&#34;&gt;Simple one pass&lt;/h2&gt;

&lt;p&gt;we can directly keep on adding the difference between the consecutive numbers of the array if the second number is larger than the first one, and at the total sum we obtain will be the maximum profit.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int maxProfit(int[] prices) {
        int max = 0;
        for(int i = 1; i &amp;lt; prices.length; i ++) {
            if(prices[i] &amp;gt; prices[i-1])
                max += prices[i]-prices[i-1];
        }
        return max;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;multiple-transactions-with-cooldown:bc34b67cdae43a991edbce9949a535fb&#34;&gt;Multiple transactions with cooldown&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/&#34;&gt;LeetCode 309&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;example-1:bc34b67cdae43a991edbce9949a535fb&#34;&gt;Example&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;prices = [1, 2, 3, 0, 2]
maxProfit = 3
transactions = [buy, sell, cooldown, buy, sell]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-2:bc34b67cdae43a991edbce9949a535fb&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;Dynamic programming: tracking the maxProfit for ending with sell and buy&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;buy[i] = max(sell[i-2]-price, buy[i-1])
sell[i] = max(buy[i-1]+price, sell[i-1])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Can reduce the space:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;preBuy = curBuy;
curBuy = max(preSell-num, preBuy);
preSell = curSell;
curSell = max(preBuy+num, preSell);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Java code&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int maxProfit(int[] prices) {
        int preSell = 0, curSell = 0;
		int curBuy = Integer.MIN_VALUE, preBuy;
        for(int price: prices) {
            preBuy = curBuy;
            curBuy = Math.max(preSell - price, preBuy);
            preSell = curSell;
            curSell = Math.max(preBuy + price, preSell);
        }
        return curSell;
    }

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Bit Manipulation</title>
      <link>http://yjn93.github.io/dev/Bit-Manipulation/</link>
      <pubDate>Sun, 13 Nov 2016 10:46:27 -0500</pubDate>
      
      <guid>http://yjn93.github.io/dev/Bit-Manipulation/</guid>
      <description>

&lt;h1 id=&#34;clever-tricks:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Clever Tricks&lt;/h1&gt;

&lt;h3 id=&#34;get-the-rightmost-set-bit:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Get the rightmost set bit&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;	num &amp;amp;= -num;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;set-the-rightmost-1-to-0:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Set the rightmost 1 to 0&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;	num &amp;amp;= (num-1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;facts:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Facts&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;~(num-1) == -num&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;single-number-iii:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Single Number III&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/single-number-iii/&#34;&gt;LeetCode 260&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.&lt;/p&gt;

&lt;h2 id=&#34;example:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Example:&lt;/h2&gt;

&lt;p&gt;Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].&lt;/p&gt;

&lt;h2 id=&#34;solution:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;In the first pass of for loop, we XOR all elements in the array, and get the XOR of the two numbers we need to find.&lt;/p&gt;

&lt;p&gt;The second pass is hard to come up with, we use the trick in the first session to get the rightmost set bit of the XOR of the two target number. We can divide all elements in two groups, and the target two numbers will fall into different groups.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int[] singleNumber(int[] nums) {
        int diff = 0;
        for(int num: nums) {
            diff ^= num;
        }
        diff &amp;amp;= -diff;
        int[] result = {0,0};
        for(int num: nums) {
            if((num &amp;amp; diff) == 0)
                result[0] ^= num;
            else
                result[1] ^= num;
        }
        return result;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;single-number-ii:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Single Number II&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/single-number-ii/&#34;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given an array of integers, every element appears three times except for one. Find that single one.&lt;/p&gt;

&lt;h2 id=&#34;solution-1:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public int singleNumber(int[] nums) {
        int ones = 0, twos = 0;
        for(int num: nums) {
            ones = (ones ^ num) &amp;amp; ~twos;
            twos = (twos ^ num) &amp;amp; ~ones;
        }
        return ones;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;missing-number:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Missing Number&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/missing-number/&#34;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given an array containing n distinct numbers taken from 0, 1, 2, &amp;hellip;, n, find the one that is missing from the array.&lt;/p&gt;

&lt;h2 id=&#34;example-1:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Example&lt;/h2&gt;

&lt;p&gt;Given nums = [0, 1, 3] return 2.&lt;/p&gt;

&lt;h2 id=&#34;solution-2:3344d83625fb333615fef7b8a8bdad05&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public int missingNumber(int[] nums) {
        int result = nums.length;
        for(int i = 0; i &amp;lt; nums.length; i ++) {
            result ^= i;
            result ^= nums[i];
        }
        return result;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Counting Bits</title>
      <link>http://yjn93.github.io/dev/Counting-Bits/</link>
      <pubDate>Sat, 12 Nov 2016 15:10:24 -0500</pubDate>
      
      <guid>http://yjn93.github.io/dev/Counting-Bits/</guid>
      <description>

&lt;h1 id=&#34;problem-description:022354bb3fdd3cdde4f44cb9f57b56b0&#34;&gt;Problem description&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/counting-bits/&#34;&gt;LeetCode 338&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1&amp;rsquo;s in their binary representation and return them as an array.&lt;/p&gt;

&lt;h2 id=&#34;example:022354bb3fdd3cdde4f44cb9f57b56b0&#34;&gt;Example:&lt;/h2&gt;

&lt;p&gt;For num = 5 you should return [0,1,1,2,1,2]&lt;/p&gt;

&lt;h2 id=&#34;my-dp-solution:022354bb3fdd3cdde4f44cb9f57b56b0&#34;&gt;My DP Solution&lt;/h2&gt;

&lt;p&gt;This problem can be solved by dynamic programming because the count of bits follow certains rules as the number grows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;		0	0
		1	1
		2	10
		3	11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The number 2 is adding another bit 1 in front of number 0; the number 3 is adding another bit 1 at the beginning of number 1. So my solution is to track the previous size of numbers that can be represented by a fix number of bits. For example, we have 0, 1 initially, the size is 2. Then for 3, 4, we apply the formula:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dp[i] = dp[i-size] + 1
dp[2] = dp[2 - 2] + 1 = dp[0] + 1 
dp[3] = dp[3 - 2] + 1 = dp[1] + 1

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, for number 4, we need more bits to represent it, so the previous size is updated to 4, and dp[4], dp[5], dp[6], dp[7] can be calculated by dp[0], dp[1], dp[2], dp[3]. My code is as following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int[] countBits(int num) {
        if(num == 0) return new int[]{0};
        int[] dp = new int[num+1];
        dp[0] = 0;
        dp[1] = 1;
        int size = 2;
        for(int i = 2; i &amp;lt;= num; i ++) {
            if(i - size == size)
                size = i;
            dp[i] = 1 + dp[i-size];
        }
        return dp;
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;another-dp-solution-combining-bit-manipulation:022354bb3fdd3cdde4f44cb9f57b56b0&#34;&gt;Another DP solution combining Bit Manipulation&lt;/h2&gt;

&lt;p&gt;Instead of adding the bit 1 infront of the previous cycle, this brilliant solution think it as deleting the last bit to obtain the number of bits without last bit, then add another counting for last bit if the last bit is 1.&lt;/p&gt;

&lt;p&gt;4-line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int[] countBits(int num) {
        int[] dp = new int[num+1];
        for(int i = 1; i &amp;lt;= num; i ++) 
            dp[i] = dp[i&amp;gt;&amp;gt;1] + (i&amp;amp;1);
        return dp;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice the priority for &amp;amp; operator is lower than +, so we need to use () for (i&amp;amp;1).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>最好的自己</title>
      <link>http://yjn93.github.io/blog/%E6%9C%80%E5%A5%BD%E7%9A%84%E8%87%AA%E5%B7%B1/</link>
      <pubDate>Sat, 08 Oct 2016 17:05:40 -0400</pubDate>
      
      <guid>http://yjn93.github.io/blog/%E6%9C%80%E5%A5%BD%E7%9A%84%E8%87%AA%E5%B7%B1/</guid>
      <description>&lt;p&gt;最近觉得自己格外迷茫，人生一直按部就班的过，考高中，考大学，申请国外研究生，可却完全不知道自己喜欢什么，想要什么。忽然有一天需要自己承担责任，自己做决定，就纠结的要死，完全想象不到一年后的自己会在哪里做什么。&lt;/p&gt;

&lt;p&gt;我害怕把日子过成黑白片；也害怕找不到自己想要的彩色是什么。&lt;/p&gt;

&lt;p&gt;昨天知乎了两件事，一个是安稳，一个是快乐。&lt;/p&gt;

&lt;p&gt;其实每个人都追求安稳，只不过稳定的层次不一样，有人在一楼安稳下来了，觉得这么过就很好，而有的人在二楼安稳却还想要努力一把去三楼安稳。&lt;/p&gt;

&lt;p&gt;“知道了生活的现实，却依然愿意走出「稳定」的小绿洲，踏上那荆棘满地却又风景如画的路途，我觉得这才是真正的勇敢和乐观&amp;rdquo; ——知乎&lt;/p&gt;

&lt;p&gt;关于快乐，我曾经跟室友讨论过，她想要什么样的生活，她说想要快乐的生活。我额子也老说，还是觉得活着很好，很快乐。我也很想要热爱生活，可是不知道为什么会那么烦，不知道要怎么快乐。&lt;/p&gt;

&lt;p&gt;又看了知乎，有这样一个答案：&lt;/p&gt;

&lt;p&gt;想太多“意义”，想太多“快不快乐”，杀死了我们的“快乐”。
“理智”杀死了我们的快乐。 我们想了太多，算计太多，失掉了快乐需要的感性。嗯，不去想它怎样？就着手做好自己手头的事情。&lt;/p&gt;

&lt;p&gt;是啊，本来没有什么烦恼，现在想太多没有定数的事情给自己徒增烦恼。以前觉得别人说&amp;rdquo;不想长大&amp;rdquo;都是矫情，人生好不容易过到了现在，我可不想回到以前。而最近真的有点不想长大了，害怕未来也后悔过去有些事没有做，或许这是真的不再年少了吧。&lt;/p&gt;

&lt;p&gt;今天看了《最好的我们》, 作者八月长安是个知道自己想要什么的人。作品塑造的也是比我优秀还比我努力的人。我想要一个这样纯粹的爱情，也怀念自己曾经拼搏过的时光。&lt;/p&gt;

&lt;p&gt;我从来都没有达到自己心目中最好的自己，希望自己能像准备高考，准备GRE时一样，不畏艰难再努力一把，少想多做，相信也能自然而然的获得快乐。&lt;/p&gt;

&lt;p&gt;最近练瑜伽老师是个平静的老奶奶，她教我们冥想“You have nowhere to go and nothing to do”。乱想并不能改变去向与未来，还是踏踏实实做好眼前的事吧。&lt;/p&gt;

&lt;p&gt;先定一个小小的目标，比如瘦个5斤~&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Cheat sheet</title>
      <link>http://yjn93.github.io/dev/cheat-sheet/</link>
      <pubDate>Wed, 06 Jul 2016 00:09:51 -0400</pubDate>
      
      <guid>http://yjn93.github.io/dev/cheat-sheet/</guid>
      <description>

&lt;h2 id=&#34;vim-reference:973531de47c0d1a1c68391da818ea75f&#34;&gt;Vim Reference&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.fprintf.net/vimCheatSheet.html&#34;&gt;Vim Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.radford.edu/~mhtay/CPSC120/VIM_Editor_Commands.htm&#34;&gt;Vim Editer Command&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>http://yjn93.github.io/about/</link>
      <pubDate>Tue, 05 Jul 2016 22:28:14 -0400</pubDate>
      
      <guid>http://yjn93.github.io/about/</guid>
      <description>

&lt;h2 id=&#34;timeline:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;Timeline&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2011 Undergrads.CS@Nanjing University&lt;/li&gt;
&lt;li&gt;2015 Master.CS@McGill University&lt;/li&gt;
&lt;li&gt;2016 Summer Intern@Morgan Stanley&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;principles:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;Principles&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Keep everything (code and life) simple and clear&lt;/li&gt;
&lt;li&gt;Caring and considerate, love and peace&lt;/li&gt;
&lt;li&gt;Step out of the comfort zone&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>